{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#django-quotes","title":"Django Quotes","text":"<p>A simple reusable Django app that allows you to collect quotes from arbitrary groups of characters, and then serve random quotes or Markov-chain generated sentences based upon them. Includes a Bootstrap compatible set of templates an optional REST API.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Documentation and a full test suite.</li> <li>Support for abstract grouping of quote sources.</li> <li>Convenience methods for fetching a random quote.</li> <li>Object-level permissions via django-rules.</li> <li>Generate sentences based off of a Markov-chain for individual sources and groups using natural language processing.</li> <li>Bootstrap-compatible templates.</li> <li>A simple REST API for fetching data via JSON with CORS support.</li> </ul> <p>Check out the documentation for installation and quickstart instructions.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#032","title":"0.3.2","text":"<ul> <li>Security update: removes <code>py</code> from dependencies as no longer needed and has a vulnerability.</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<ul> <li>Adds support for python 3.11 by upgrading <code>spacy</code> dependency to 3.4.2 and adding <code>py</code>.</li> </ul> <p>Upgrade Note: You will want to update your spacy language model after updating. You can do this by:</p> <pre><code>python -m spacy download en_core_web_sm\n</code></pre>"},{"location":"changelog/#030","title":"0.3.0","text":"<ul> <li>Add <code>pub_date</code> field to <code>Quote</code> model. This prevents a quote with a future date from appearing in random requests.</li> </ul>"},{"location":"changelog/#024","title":"0.2.4","text":"<ul> <li>Update documentation links on PyPI.</li> </ul>"},{"location":"changelog/#023","title":"0.2.3","text":"<ul> <li>Bug: Fixed issue with pagination not showing accurate count for all objects.</li> <li>Bug: Fix page title when viewing a list of sources for a SourceGroup.</li> </ul>"},{"location":"changelog/#022","title":"0.2.2","text":"<p>Update for latest mypy and fixes for documentation builds.</p>"},{"location":"changelog/#021","title":"0.2.1","text":"<ul> <li>Enable type annotations with py.typed.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li><code>SourceGroups</code> no longer require a unique name (since users won't know what else is there anyway).</li> <li>New slug generation to ensure that slugs remain unique.</li> <li>It is no longer possible to specify a slug within a given create form for either <code>SourceGroup</code> or <code>Source</code> objects.</li> </ul>"},{"location":"changelog/#013","title":"0.1.3","text":"<ul> <li>Adds a configuration option for controlling how many quotes should be retrieved for random quote selection from a   <code>SourceGroup</code>. To make use of this option, add the variable <code>MAX_QUOTES_FOR_RANDOM_GROUP_SET</code> to your project's   <code>settings.py</code>.</li> <li>Bugfix: <code>SourceGroup</code> random group selection now prioritizes quotes that have been served less often via the   <code>QuoteStats.times_used</code> value. This was already the case when selecting from a single <code>Source</code>, but the behavior   is now consistent for <code>SourceGroup</code> as well.</li> </ul>"},{"location":"changelog/#012","title":"0.1.2","text":"<ul> <li>Adds a configuration option for controlling how many quotes should be retrieved for random quote selection.   To make use of this option, add the variable <code>MAX_QUOTES_FOR_RANDOM_SET</code> in your project's <code>settings.py</code> file.</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at daniel@andrlik.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>Contributions to either the code, localization, or the documentation are very welcome!</p>"},{"location":"contributing/#development-task-runner","title":"Development task runner","text":"<p>We use <code>just</code> to execute common tasks. It is available for any platform. Once installed, you can see a list of available commands by running <code>just --list</code>.</p>"},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>We use <code>rye</code> to manage the Python dependencies. If you don't have <code>rye</code>, you should install with <code>just rye-install</code>.</p> <p>To install dependencies and prepare <code>pre-commit</code> hooks you would need to run the <code>setup</code> command:</p> <pre><code>just bootstrap\n</code></pre>"},{"location":"contributing/#running-updates","title":"Running updates","text":"<p>After pulling new updates from the repository you can quickly install updated dependencies and run database migrations by running <code>just bootstrap</code>.</p>"},{"location":"contributing/#codestyle","title":"Codestyle","text":"<p>After installation you may execute code formatting.</p> <pre><code>just fmt\n</code></pre>"},{"location":"contributing/#checks","title":"Checks","text":"<p>Many checks are configured for this project.</p> <p>To run your test suite:</p> <pre><code>just test\n</code></pre> <p>To use pyright for type checking run: <pre><code>just check-types\n</code></pre></p> <p>To run linting:</p> <pre><code>just lint\n</code></pre> <p>The <code>just safety</code> command will look at the security of your code.</p>"},{"location":"contributing/#before-submitting","title":"Before submitting","text":"<p>Before submitting your code please do the following steps:</p> <ol> <li>Add any changes you want</li> <li>Add tests for the new changes</li> <li>Edit documentation if you have changed something significant</li> <li>Run <code>just fmt</code> to format your changes.</li> <li>Run <code>just lint</code> to ensure that types, security and docstrings are okay.</li> <li>Add your name to the <code>CONTRIBUTERS.txt</code> file.</li> </ol>"},{"location":"contributing/#other-help","title":"Other help","text":"<p>You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.</p>"},{"location":"managing_quotes/","title":"Managing Sources and Quotes","text":"<p>Django-Quotes uses a number of rudimentary data models with basic scaffolding views to manage the data. User-based permissions are used to control access to the data.</p>"},{"location":"managing_quotes/#models","title":"Models","text":""},{"location":"managing_quotes/#source-group","title":"Source Group","text":"<p>             Bases: <code>AbstractOwnerModel</code>, <code>RulesModelMixin</code>, <code>TimeStampedModel</code></p> <p>An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to the same group. For example, a novel or series if you plan to quote the characters within individually.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Database primary key for the object.</p> <code>name</code> <code>str</code> <p>Human readable string to name the group. This will be converted to a slug prefix.</p> <code>description</code> <code>str</code> <p>A description of the group for convenience. Markdown can be used here for styling.</p> <code>description_rendered</code> <code>str</code> <p>The HTML representation of the description string. Generated automatically.</p> <code>owner</code> <code>User</code> <p>The user that created the group and therefore owns it.</p> <code>public</code> <code>bool</code> <p>Is this group public or private. Defaults to False.</p> <code>allow_submissions</code> <code>bool</code> <p>Allow other users to submit characters to this. Not yet implemented.</p> <code>slug</code> <code>str</code> <p>A unique slug to represent this group. Generated automatically from name.</p> <code>created</code> <code>datetime</code> <p>When this object was first created. Auto-generated.</p> <code>modified</code> <code>datetime</code> <p>Last time this object was modified. Auto-generated.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class SourceGroup(AbstractOwnerModel, RulesModelMixin, TimeStampedModel, metaclass=RulesModelBase):\n    \"\"\"\n    An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to\n    the same group. For example, a novel or series if you plan to quote the characters within individually.\n\n    Attributes:\n        id (int): Database primary key for the object.\n        name (str): Human readable string to name the group. This will be converted to a slug prefix.\n        description (str): A description of the group for convenience. Markdown can be used here for styling.\n        description_rendered (str): The HTML representation of the description string. Generated automatically.\n        owner (User): The user that created the group and therefore owns it.\n        public (bool): Is this group public or private. Defaults to False.\n        allow_submissions (bool): Allow other users to submit characters to this. Not yet implemented.\n        slug (str): A unique slug to represent this group. Generated automatically from name.\n        created (datetime): When this object was first created. Auto-generated.\n        modified (datetime): Last time this object was modified. Auto-generated.\n\n    \"\"\"\n\n    if TYPE_CHECKING:\n        source_set: RelatedManager[Source]\n\n    name = models.CharField(\n        _(\"Source Name\"),\n        max_length=50,\n        help_text=_(\"A source for individuals making the quotes. Use as an abstract grouping.\"),\n        db_index=True,\n    )\n    description = models.TextField(\n        help_text=_(\"Description for the source. You can style using Markdown.\"),\n        null=True,\n        blank=True,\n    )\n    description_rendered = models.TextField(\n        help_text=_(\"Automatically generated from description\"), null=True, blank=True\n    )\n    slug = models.SlugField(\n        unique=True,\n        max_length=70,\n        editable=False,\n        blank=True,\n        help_text=_(\"Unique slug for this group.\"),\n    )\n\n    class Meta:\n        rules_permissions = {\n            \"add\": rules.is_authenticated,\n            \"read\": is_owner_or_public,\n            \"edit\": is_owner,\n            \"delete\": is_owner,\n        }\n        ordering = [\"name\"]\n\n    def __str__(self):  # pragma: nocover\n        return self.name\n\n    def save(self, *args, **kwargs):\n        if not self.slug:  # Once this slug is set, it does not change except through devil pacts\n            logger.debug(\"Group is being saved and a slug was provided.\")\n            self.slug = generate_unique_slug_for_model(model_class=type(self), text=self.name)\n        super().save(*args, **kwargs)\n\n    def refresh_from_db(self, *args, **kwargs):\n        super().refresh_from_db(*args, **kwargs)\n        cached_properties = [\"total_sources\", \"markov_sources\", \"total_quotes\"]\n        for prop in cached_properties:\n            try:\n                del self.__dict__[prop]\n            except KeyError:  # pragma: nocover\n                pass\n\n    @cached_property\n    def total_sources(self) -&gt; int:\n        return Source.objects.filter(group=self).count()\n\n    @cached_property\n    def markov_sources(self) -&gt; int:\n        return Source.objects.filter(group=self, allow_markov=True).count()\n\n    @cached_property\n    def total_quotes(self) -&gt; int:\n        return Quote.objects.filter(source__in=Source.objects.filter(group=self)).count()\n\n    @cached_property\n    def markov_ready(self) -&gt; bool:\n        if (\n            self.markov_sources &gt; 0\n            and Quote.objects.filter(source__in=self.source_set.filter(allow_markov=True)).count() &gt; 10  # noqa:PLR2004\n        ):\n            return True\n        return False\n\n    def generate_markov_sentence(self, max_characters: int | None = 280) -&gt; str | None:\n        \"\"\"\n        Generate a markov sentence based on quotes from markov enabled characters for the group.\n\n        :return: str or None\n        \"\"\"\n        if self.markov_ready:\n            logger.debug(\"Group is ready for markov sentences. Checking model...\")\n            mmodel = GroupMarkovModel.objects.get(group=self)\n            if mmodel.data is None:\n                logger.debug(\"Markov model for group is not generated yet! Generating...\")\n                mmodel.generate_model_from_corpus()\n            logger.debug(\"Loading text model...\")\n            text_model = MarkovPOSText.from_json(mmodel.data)\n            logger.debug(\"Generating sentence...\")\n            sentence: str | None = text_model.make_short_sentence(max_chars=max_characters)\n            if sentence is not None:\n                logger.debug(f\"Returning generated sentence: '{sentence}'\")\n                return sentence\n        logger.debug(\"Group is not ready for markov requests yet!\")\n        return None\n\n    def get_random_quote(self, max_quotes_to_process: int | None = MAX_QUOTES_FOR_RANDOM_GROUP_SET) -&gt; Any:\n        \"\"\"\n        Get a random quote object from any of the characters defined within the group.\n        Prioritizes quotes that have been returned less often.\n\n        :return: ``Quote`` object or None if no quotes are defined.\n        \"\"\"\n        # TODO: Create Q object to filter for null datetimes or less than now.\n        quotes = (\n            Quote.objects.filter(source__in=self.source_set.all())\n            .filter(models.Q(pub_date__isnull=True) | models.Q(pub_date__lte=timezone.now()))\n            .select_related(\"stats\")\n            .order_by(\"stats__times_used\")[:max_quotes_to_process]\n        )\n        if quotes.exists():\n            quote = random.choice(list(quotes))  # noqa: S311\n            quote_random_retrieved.send(type(quote.source), instance=quote.source, quote_retrieved=quote)\n            return quote\n        return None\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.SourceGroup.generate_markov_sentence","title":"<code>generate_markov_sentence(max_characters=280)</code>","text":"<p>Generate a markov sentence based on quotes from markov enabled characters for the group.</p> <p>:return: str or None</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def generate_markov_sentence(self, max_characters: int | None = 280) -&gt; str | None:\n    \"\"\"\n    Generate a markov sentence based on quotes from markov enabled characters for the group.\n\n    :return: str or None\n    \"\"\"\n    if self.markov_ready:\n        logger.debug(\"Group is ready for markov sentences. Checking model...\")\n        mmodel = GroupMarkovModel.objects.get(group=self)\n        if mmodel.data is None:\n            logger.debug(\"Markov model for group is not generated yet! Generating...\")\n            mmodel.generate_model_from_corpus()\n        logger.debug(\"Loading text model...\")\n        text_model = MarkovPOSText.from_json(mmodel.data)\n        logger.debug(\"Generating sentence...\")\n        sentence: str | None = text_model.make_short_sentence(max_chars=max_characters)\n        if sentence is not None:\n            logger.debug(f\"Returning generated sentence: '{sentence}'\")\n            return sentence\n    logger.debug(\"Group is not ready for markov requests yet!\")\n    return None\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.SourceGroup.get_random_quote","title":"<code>get_random_quote(max_quotes_to_process=MAX_QUOTES_FOR_RANDOM_GROUP_SET)</code>","text":"<p>Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often.</p> <p>:return: <code>Quote</code> object or None if no quotes are defined.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def get_random_quote(self, max_quotes_to_process: int | None = MAX_QUOTES_FOR_RANDOM_GROUP_SET) -&gt; Any:\n    \"\"\"\n    Get a random quote object from any of the characters defined within the group.\n    Prioritizes quotes that have been returned less often.\n\n    :return: ``Quote`` object or None if no quotes are defined.\n    \"\"\"\n    # TODO: Create Q object to filter for null datetimes or less than now.\n    quotes = (\n        Quote.objects.filter(source__in=self.source_set.all())\n        .filter(models.Q(pub_date__isnull=True) | models.Q(pub_date__lte=timezone.now()))\n        .select_related(\"stats\")\n        .order_by(\"stats__times_used\")[:max_quotes_to_process]\n    )\n    if quotes.exists():\n        quote = random.choice(list(quotes))  # noqa: S311\n        quote_random_retrieved.send(type(quote.source), instance=quote.source, quote_retrieved=quote)\n        return quote\n    return None\n</code></pre>"},{"location":"managing_quotes/#source","title":"Source","text":"<p>             Bases: <code>AbstractOwnerModel</code>, <code>RulesModelMixin</code>, <code>TimeStampedModel</code></p> <p>An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific author.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Database primary key for the object.</p> <code>name</code> <code>str</code> <p>Unique name of a character within a <code>CharacterGroup</code> for this entity.</p> <code>group</code> <code>SourceGroup</code> <p>The parent <code>SourceGroup</code>.</p> <code>slug</code> <code>str</code> <p>Slug made up of a generated version of the character name and the group slug prefix.</p> <code>description</code> <code>str</code> <p>Description for the character. Markdown can be used for styling.</p> <code>description_rendered</code> <code>str</code> <p>HTML representation of the description for convenience. Automatically generated.</p> <code>allow_markov</code> <code>bool</code> <p>Allow markov quotes to be requested from this character? Default False.</p> <code>owner</code> <code>User</code> <p>The user that created and owns this character.</p> <code>public</code> <code>bool</code> <p>Is the character public to other users? Defaults to False.</p> <code>allow_submissions</code> <code>bool</code> <p>Allow other users to submit quotes for this character? Defaults to False.</p> <code>created</code> <code>datetime</code> <p>When this object was first created. Auto-generated.</p> <code>modified</code> <code>datetime</code> <p>Last time this object was modified. Auto-generated.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class Source(AbstractOwnerModel, RulesModelMixin, TimeStampedModel, metaclass=RulesModelBase):\n    \"\"\"\n    An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific\n    author.\n\n    Attributes:\n        id (int): Database primary key for the object.\n        name (str): Unique name of a character within a ``CharacterGroup`` for this entity.\n        group (SourceGroup): The parent ``SourceGroup``.\n        slug (str): Slug made up of a generated version of the character name and the group slug prefix.\n        description (str): Description for the character. Markdown can be used for styling.\n        description_rendered (str): HTML representation of the description for convenience. Automatically generated.\n        allow_markov (bool): Allow markov quotes to be requested from this character? Default False.\n        owner (User): The user that created and owns this character.\n        public (bool): Is the character public to other users? Defaults to False.\n        allow_submissions (bool): Allow other users to submit quotes for this character? Defaults to False.\n        created (datetime): When this object was first created. Auto-generated.\n        modified (datetime): Last time this object was modified. Auto-generated.\n\n    \"\"\"\n\n    if TYPE_CHECKING:\n        quote_set: RelatedManager[Quote]\n\n    name = models.CharField(max_length=100, help_text=_(\"Name of the character\"))\n    slug = models.SlugField(\n        max_length=250,\n        help_text=_(\"Global slug of the character, will be auto generated from name and group if not overridden.\"),\n        blank=True,\n        editable=False,\n        unique=True,\n        db_index=True,\n    )\n    description = models.TextField(\n        null=True,\n        blank=True,\n        help_text=_(\"Description of this character. You can style this with Markdown.\"),\n    )\n    description_rendered = models.TextField(\n        null=True, blank=True, help_text=_(\"Automatically generated from description.\")\n    )\n    allow_markov = models.BooleanField(default=False, help_text=_(\"Allow to be used in markov chains?\"))\n    group = models.ForeignKey(\n        SourceGroup,\n        on_delete=models.CASCADE,\n        help_text=_(\"The group this character belongs to.\"),\n    )\n\n    class Meta:\n        rules_permissions = {\n            \"add\": rules.is_authenticated,\n            \"read\": is_owner_or_public,\n            \"edit\": is_owner,\n            \"delete\": is_owner,\n        }\n\n    def __str__(self):  # pragma: nocover\n        return self.name\n\n    def save(self, *args, **kwargs):\n        if not self.slug:\n            self.slug = generate_unique_slug_for_model(type(self), text=f\"{self.group.slug} {self.name}\")\n        super().save(*args, **kwargs)\n\n    @property\n    def markov_ready(self) -&gt; bool:\n        \"\"\"\n        Conducts sanity checks to see if requesting a markov chain is feasible. Markov must be enabled for a character\n        and there must be a sufficient corpus to generate a sentence from. Currently set at a minimum of 10 quotes.\n\n        :return: bool\n        \"\"\"\n        if self.allow_markov and Quote.objects.filter(source=self).count() &gt; 10:  # noqa:PLR2004\n            return True\n        return False\n\n    def get_markov_sentence(self, max_characters: int | None = 280) -&gt; str | None:\n        \"\"\"\n        If valid, generate a markov sentence. If not, return None.\n\n        :param max_characters: Optional maximum limit of characters in the return set. Default: 280\n        :return: str or None\n        \"\"\"\n        logger.debug(\"Checking to see if character is markov ready...\")\n        if self.markov_ready:\n            logger.debug(\"It IS ready. Fetching markov model.\")\n            markov_model = SourceMarkovModel.objects.get(source=self)\n            if not markov_model.data:\n                logger.debug(\"No model defined yet, generating...\")\n                markov_model.generate_model_from_corpus()\n            text_model = MarkovPOSText.from_json(markov_model.data)\n            logger.debug(\"Markov text model loaded. Generating sentence.\")\n            sentence: str | None = text_model.make_short_sentence(max_chars=max_characters)\n            if sentence is not None:\n                markov_sentence_generated.send(type(self), instance=self)\n                return sentence\n        return None\n\n    def get_random_quote(self, max_quotes_to_process: int | None = MAX_QUOTES_FOR_RANDOM_SET) -&gt; Any | None:\n        \"\"\"\n        This actually not all that random. It's going to grab the quotes\n        ordered ordered by how infrequently they've been returned, and then grab a random one\n        in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None.\n\n        :return: ``Quote`` object or None\n        \"\"\"\n        quotes_to_pick = (\n            Quote.objects.filter(source=self)\n            .filter(models.Q(pub_date__isnull=True) | models.Q(pub_date__lte=timezone.now()))\n            .select_related(\"stats\")\n            .order_by(\"stats__times_used\")[:max_quotes_to_process]\n        )\n        if quotes_to_pick.exists():\n            # Select a random index in the result set.\n            quote_to_return = random.choice(list(quotes_to_pick))  # noqa: S311\n            quote_random_retrieved.send(type(self), instance=self, quote_retrieved=quote_to_return)\n            return quote_to_return\n        return None\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.Source.markov_ready","title":"<code>markov_ready: bool</code>  <code>property</code>","text":"<p>Conducts sanity checks to see if requesting a markov chain is feasible. Markov must be enabled for a character and there must be a sufficient corpus to generate a sentence from. Currently set at a minimum of 10 quotes.</p> <p>:return: bool</p>"},{"location":"managing_quotes/#django_quotes.models.Source.get_markov_sentence","title":"<code>get_markov_sentence(max_characters=280)</code>","text":"<p>If valid, generate a markov sentence. If not, return None.</p> <p>:param max_characters: Optional maximum limit of characters in the return set. Default: 280 :return: str or None</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def get_markov_sentence(self, max_characters: int | None = 280) -&gt; str | None:\n    \"\"\"\n    If valid, generate a markov sentence. If not, return None.\n\n    :param max_characters: Optional maximum limit of characters in the return set. Default: 280\n    :return: str or None\n    \"\"\"\n    logger.debug(\"Checking to see if character is markov ready...\")\n    if self.markov_ready:\n        logger.debug(\"It IS ready. Fetching markov model.\")\n        markov_model = SourceMarkovModel.objects.get(source=self)\n        if not markov_model.data:\n            logger.debug(\"No model defined yet, generating...\")\n            markov_model.generate_model_from_corpus()\n        text_model = MarkovPOSText.from_json(markov_model.data)\n        logger.debug(\"Markov text model loaded. Generating sentence.\")\n        sentence: str | None = text_model.make_short_sentence(max_chars=max_characters)\n        if sentence is not None:\n            markov_sentence_generated.send(type(self), instance=self)\n            return sentence\n    return None\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.Source.get_random_quote","title":"<code>get_random_quote(max_quotes_to_process=MAX_QUOTES_FOR_RANDOM_SET)</code>","text":"<p>This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None.</p> <p>:return: <code>Quote</code> object or None</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def get_random_quote(self, max_quotes_to_process: int | None = MAX_QUOTES_FOR_RANDOM_SET) -&gt; Any | None:\n    \"\"\"\n    This actually not all that random. It's going to grab the quotes\n    ordered ordered by how infrequently they've been returned, and then grab a random one\n    in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None.\n\n    :return: ``Quote`` object or None\n    \"\"\"\n    quotes_to_pick = (\n        Quote.objects.filter(source=self)\n        .filter(models.Q(pub_date__isnull=True) | models.Q(pub_date__lte=timezone.now()))\n        .select_related(\"stats\")\n        .order_by(\"stats__times_used\")[:max_quotes_to_process]\n    )\n    if quotes_to_pick.exists():\n        # Select a random index in the result set.\n        quote_to_return = random.choice(list(quotes_to_pick))  # noqa: S311\n        quote_random_retrieved.send(type(self), instance=self, quote_retrieved=quote_to_return)\n        return quote_to_return\n    return None\n</code></pre>"},{"location":"managing_quotes/#quote","title":"Quote","text":"<p>             Bases: <code>AbstractOwnerModel</code>, <code>RulesModelMixin</code>, <code>TimeStampedModel</code></p> <p>A quote from a given source.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Database primary key for the object.</p> <code>quote</code> <code>str</code> <p>The quote text to use. You can use Markdown for styling. Must be &lt;= 280 characters for tweets</p> <code>quote_rendered</code> <code>str</code> <p>HTML rendered version of the quote field. Automatically generated.</p> <code>citation</code> <code>str</code> <p>Optional description of quote source, e.g. episode number or book title.</p> <code>citation_url</code> <code>str</code> <p>Optional accompanying URL for the citation.</p> <code>character</code> <code>Source</code> <p>The source of this quote.</p> <code>owner</code> <code>User</code> <p>The user that created and owns this quote.</p> <code>created</code> <code>datetime</code> <p>When this object was first created. Auto-generated.</p> <code>modified</code> <code>datetime</code> <p>Last time this object was modified. Auto-generated.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class Quote(AbstractOwnerModel, RulesModelMixin, TimeStampedModel, metaclass=RulesModelBase):\n    \"\"\"\n    A quote from a given source.\n\n    Attributes:\n        id (int): Database primary key for the object.\n        quote (str): The quote text to use. You can use Markdown for styling. Must be &lt;= 280 characters for tweets\n        quote_rendered (str): HTML rendered version of the quote field. Automatically generated.\n        citation (str): Optional description of quote source, e.g. episode number or book title.\n        citation_url (str): Optional accompanying URL for the citation.\n        character (Source): The source of this quote.\n        owner (User): The user that created and owns this quote.\n        created (datetime): When this object was first created. Auto-generated.\n        modified (datetime): Last time this object was modified. Auto-generated.\n\n    \"\"\"\n\n    if TYPE_CHECKING:\n        id: int\n\n    quote = models.CharField(\n        max_length=280,  # Keep the base limit to 280 so that quotes are 'tweetable'\n        help_text=\"Plain text representation of quote. You can use Markdown here.\",\n    )\n    quote_rendered = models.TextField(\n        null=True,\n        blank=True,\n        help_text=_(\"HTML rendered version of quote generated from quote plain text.\"),\n    )\n    source = models.ForeignKey(\n        Source,\n        on_delete=models.CASCADE,\n        help_text=_(\"The source of this quote, i.e. name.\"),\n    )\n    citation = models.CharField(\n        max_length=250,\n        blank=True,\n        null=True,\n        help_text=_(\"Where is this quote from? Episode #, book?\"),\n    )\n    citation_url = models.URLField(null=True, blank=True, help_text=_(\"URL for citation, if applicable.\"))\n    pub_date = models.DateTimeField(\n        null=True,\n        blank=True,\n        help_text=_(\"When is the earliest time this should appear in random results?\"),\n    )\n\n    class Meta:\n        rules_permissions = {\n            # \"add\": is_character_owner,\n            \"read\": is_owner_or_public,\n            \"edit\": is_owner,\n            \"delete\": is_owner,\n        }\n\n    def __str__(self):  # pragma: nocover\n        return f\"{self.source.name}: {self.quote}\"\n</code></pre>"},{"location":"managing_quotes/#source-markov-model","title":"Source Markov Model","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>The cached markov model for a given source. The database object for this is automatically created whenever a new character object is saved.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Database primary key for the object.</p> <code>source</code> <code>Source</code> <p>The character who the model is sourced from.</p> <code>data</code> <code>json</code> <p>The JSON representation of the Markov model created by <code>markovify</code>.</p> <code>created</code> <code>datetime</code> <p>When this object was first created. Auto-generated.</p> <code>modified</code> <code>datetime</code> <p>Last time this object was modified. Auto-generated.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class SourceMarkovModel(TimeStampedModel):\n    \"\"\"\n    The cached markov model for a given source. The database object for this is automatically created\n    whenever a new character object is saved.\n\n    Attributes:\n        id (int): Database primary key for the object.\n        source (Source): The character who the model is sourced from.\n        data (json): The JSON representation of the Markov model created by ``markovify``.\n        created (datetime): When this object was first created. Auto-generated.\n        modified (datetime): Last time this object was modified. Auto-generated.\n\n    \"\"\"\n\n    source = models.OneToOneField(Source, on_delete=models.CASCADE)\n    data = models.JSONField(null=True, blank=True)\n\n    def __str__(self):  # pragma: nocover\n        return self.source.name\n\n    def generate_model_from_corpus(self):\n        \"\"\"\n        Collect all quotes attributed to the related character. Then\n        create, compile, and save the model.\n        \"\"\"\n        logger.debug(\"Generating text model. Fetching quotes.\")\n        quotes = Quote.objects.filter(source=self.source)\n        # Don't bother generating model if there isn't data.\n        if not quotes.exists():  # pragma: nocover\n            logger.debug(\"There are no quotes. Returning None.\")\n            return\n        logger.debug(\"Quotes retrieved! Forming into corpus.\")\n        corpus = \" \".join(quote.quote for quote in quotes)\n        logger.debug(\"Building text model.\")\n        text_model = MarkovPOSText(corpus)\n        logger.debug(\"Compiling text model.\")\n        text_model.compile(inplace=True)\n        logger.debug(\"Saving model as JSON.\")\n        self.data = text_model.to_json()\n        self.save()\n        logger.debug(\"Markov model populated to database.\")\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.SourceMarkovModel.generate_model_from_corpus","title":"<code>generate_model_from_corpus()</code>","text":"<p>Collect all quotes attributed to the related character. Then create, compile, and save the model.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def generate_model_from_corpus(self):\n    \"\"\"\n    Collect all quotes attributed to the related character. Then\n    create, compile, and save the model.\n    \"\"\"\n    logger.debug(\"Generating text model. Fetching quotes.\")\n    quotes = Quote.objects.filter(source=self.source)\n    # Don't bother generating model if there isn't data.\n    if not quotes.exists():  # pragma: nocover\n        logger.debug(\"There are no quotes. Returning None.\")\n        return\n    logger.debug(\"Quotes retrieved! Forming into corpus.\")\n    corpus = \" \".join(quote.quote for quote in quotes)\n    logger.debug(\"Building text model.\")\n    text_model = MarkovPOSText(corpus)\n    logger.debug(\"Compiling text model.\")\n    text_model.compile(inplace=True)\n    logger.debug(\"Saving model as JSON.\")\n    self.data = text_model.to_json()\n    self.save()\n    logger.debug(\"Markov model populated to database.\")\n</code></pre>"},{"location":"managing_quotes/#group-markov-model","title":"Group Markov Model","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>The cached markov model for the entire group. It is made up of every quote from every markov enabled character within the group.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The database id of this object.</p> <code>group</code> <code>SourceGroup</code> <p>The OneToOne relationship to <code>SourceGroup</code></p> <code>data</code> <code>json</code> <p>The cached markov model.</p> <code>created</code> <code>datetime</code> <p>When the object was created.</p> <code>modified</code> <code>datetime</code> <p>When the object was last modified.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class GroupMarkovModel(TimeStampedModel):\n    \"\"\"\n    The cached markov model for the entire group. It is made up of every quote from every markov enabled\n    character within the group.\n\n    Attributes:\n        id (int): The database id of this object.\n        group (SourceGroup): The OneToOne relationship to ``SourceGroup``\n        data (json): The cached markov model.\n        created (datetime): When the object was created.\n        modified (datetime): When the object was last modified.\n    \"\"\"\n\n    group = models.OneToOneField(\n        SourceGroup,\n        on_delete=models.CASCADE,\n        help_text=_(\"The character group this model belongs to.\"),\n    )\n    data = models.JSONField(null=True, blank=True, help_text=_(\"The cached markov model as JSON.\"))\n\n    def generate_model_from_corpus(self):\n        \"\"\"\n        Collect all quotes from markov enabled characters in this group and then compile the model and save it.\n        \"\"\"\n        logger.debug(f\"Gathering corpus for character group: {self.group.name}\")\n        quotes = Quote.objects.filter(source__in=Source.objects.filter(group=self.group, allow_markov=True))\n        if quotes.exists():\n            if quotes.count() &gt;= 10:  # noqa:PLR2004\n                logger.debug(\"Found sufficient quotes for a model!\")\n                corpus = \" \".join(quote.quote for quote in quotes)\n                logger.debug(\"Forming text model...\")\n                text_model = MarkovPOSText(corpus)\n                logger.debug(\"Compiling text model...\")\n                text_model.compile(inplace=True)\n                logger.debug(\"Saving compiled model to JSON...\")\n                self.data = text_model.to_json()\n                self.save()\n                logger.debug(f\"Finished building and saving group markov model for {self.group.name}!\")\n</code></pre>"},{"location":"managing_quotes/#django_quotes.models.GroupMarkovModel.generate_model_from_corpus","title":"<code>generate_model_from_corpus()</code>","text":"<p>Collect all quotes from markov enabled characters in this group and then compile the model and save it.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>def generate_model_from_corpus(self):\n    \"\"\"\n    Collect all quotes from markov enabled characters in this group and then compile the model and save it.\n    \"\"\"\n    logger.debug(f\"Gathering corpus for character group: {self.group.name}\")\n    quotes = Quote.objects.filter(source__in=Source.objects.filter(group=self.group, allow_markov=True))\n    if quotes.exists():\n        if quotes.count() &gt;= 10:  # noqa:PLR2004\n            logger.debug(\"Found sufficient quotes for a model!\")\n            corpus = \" \".join(quote.quote for quote in quotes)\n            logger.debug(\"Forming text model...\")\n            text_model = MarkovPOSText(corpus)\n            logger.debug(\"Compiling text model...\")\n            text_model.compile(inplace=True)\n            logger.debug(\"Saving compiled model to JSON...\")\n            self.data = text_model.to_json()\n            self.save()\n            logger.debug(f\"Finished building and saving group markov model for {self.group.name}!\")\n</code></pre>"},{"location":"managing_quotes/#group-stats","title":"Group Stats","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>An object for using to track usage stats for <code>CharacterGroup</code>.</p> <p>Attributes:</p> Name Type Description <code>group</code> <code>SourceGroup</code> <p>The group this is collecting stats for.</p> <code>quotes_requested</code> <code>int</code> <p>The number of times a quote from this object or its children has been requested.</p> <code>quotes_generated</code> <code>int</code> <p>The number of times a markov quote has been generated for this or it's children.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class GroupStats(TimeStampedModel):\n    \"\"\"\n    An object for using to track usage stats for ``CharacterGroup``.\n\n    Attributes:\n        group (SourceGroup): The group this is collecting stats for.\n        quotes_requested (int): The number of times a quote from this object or its children has been requested.\n        quotes_generated (int): The number of times a markov quote has been generated for this or it's children.\n    \"\"\"\n\n    group = models.OneToOneField(SourceGroup, related_name=\"stats\", on_delete=models.CASCADE)\n    quotes_requested = models.PositiveIntegerField(\n        default=0, help_text=_(\"Number of time child quotes have been requested.\")\n    )\n    quotes_generated = models.PositiveIntegerField(\n        default=0,\n        help_text=_(\"Number of times markov generated quotes have been requested.\"),\n    )\n</code></pre>"},{"location":"managing_quotes/#source-stats","title":"Source Stats","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>An object for using to track usage stats for <code>Character</code>.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Source</code> <p>The source this is collecting stats for.</p> <code>quotes_requested</code> <code>int</code> <p>The number of times a quote from this object or its children has been requested.</p> <code>quotes_generated</code> <code>int</code> <p>The number of times a markov quote has been generated for this or it's children.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class SourceStats(TimeStampedModel):\n    \"\"\"\n    An object for using to track usage stats for ``Character``.\n\n    Attributes:\n        source (Source): The source this is collecting stats for.\n        quotes_requested (int): The number of times a quote from this object or its children has been requested.\n        quotes_generated (int): The number of times a markov quote has been generated for this or it's children.\n    \"\"\"\n\n    source = models.OneToOneField(Source, related_name=\"stats\", on_delete=models.CASCADE)\n    quotes_requested = models.PositiveIntegerField(\n        default=0, help_text=_(\"Number of time child quotes have been requested.\")\n    )\n    quotes_generated = models.PositiveIntegerField(\n        default=0,\n        help_text=_(\"Number of times markov generated quotes have been requested.\"),\n    )\n</code></pre>"},{"location":"managing_quotes/#quote-stats","title":"Quote Stats","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>A simple object used to track how often an individual quote is used.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The database primary key of this object.</p> <code>quote</code> <code>Quote</code> <p>The quote this stat relates to.</p> <code>times_used</code> <code>int</code> <p>The number of times this has been used by an service such as random quote.</p> <code>created</code> <code>datetime</code> <p>When this was created.</p> <code>modified</code> <code>datetime</code> <p>When this was last modified.</p> Source code in <code>src/django_quotes/models.py</code> <pre><code>class QuoteStats(TimeStampedModel):\n    \"\"\"\n    A simple object used to track how often an individual quote is used.\n\n    Attributes:\n        id (int): The database primary key of this object.\n        quote (Quote): The quote this stat relates to.\n        times_used (int): The number of times this has been used by an service such as random quote.\n        created (datetime): When this was created.\n        modified (datetime): When this was last modified.\n    \"\"\"\n\n    quote = models.OneToOneField(\n        Quote,\n        on_delete=models.CASCADE,\n        related_name=\"stats\",\n        help_text=_(\"The Quote the stats related to.\"),\n    )\n    times_used = models.PositiveIntegerField(default=0, help_text=_(\"Times used for random quotes, etc.\"))\n\n    def __str__(self):  # pragma: nocover\n        return f\"Stats for Quote {self.quote.id}\"\n</code></pre>"},{"location":"managing_quotes/#views","title":"Views","text":"<p>The core views for managing the quotes consist of simple data entry and manipulation functions, heavily utilizing Django's generic views. All views require login.</p>"},{"location":"managing_quotes/#source-group-list","title":"Source Group List","text":"<p>Provides a paginated list of source groups created by logged in user.</p> <p>Served at <code>/app/groups/</code>.</p>"},{"location":"managing_quotes/#source-group-create","title":"Source Group Create","text":"<p>Allows a user to define a new <code>SourceGroup</code>.</p> <p>Served at <code>app/groups/create/</code>.</p>"},{"location":"managing_quotes/#source-group-detail","title":"Source Group Detail","text":"<p>Displays a detailed view of a source group with a sampling of the :ref:<code>Source</code> objects associated, with links to full listings.</p> <p>Served at <code>app/groups/&lt;slug:group&gt;/</code>.</p>"},{"location":"managing_quotes/#source-group-update","title":"Source Group Update","text":"<p>Allows user to update the source group's attributes.</p> <p>Served at <code>app/groups/&lt;slug:group&gt;/edit/</code>.</p>"},{"location":"managing_quotes/#source-group-delete","title":"Source Group Delete","text":"<p>Allows user to delete a <code>SourceGroup</code> and all child data associated with it.</p> <p>Served at <code>app/groups/&lt;slug:group&gt;/delete/</code>.</p>"},{"location":"managing_quotes/#source-list","title":"Source List","text":"<p>Paginated list of all the :ref:<code>Source</code> objects associated with a given group, along with aggregate statistics such as total quotes.</p> <p>Served at <code>app/groups/&lt;slug:group&gt;/sources/</code>.</p>"},{"location":"managing_quotes/#source-create","title":"Source Create","text":"<p>Enables a user to create a new <code>Source</code> for a given <code>SourceGroup</code>.</p> <p>Served at <code>app/groups/&lt;slug:group&gt;/sources/create/</code>.</p>"},{"location":"managing_quotes/#source-detail","title":"Source Detail","text":"<p>Detail view of the :ref:<code>Source</code> object including a sampling of recently created/modified quotes with links to full listings.</p> <p>Served at <code>app/sources/&lt;slug:source&gt;/</code>.</p>"},{"location":"managing_quotes/#source-update","title":"Source Update","text":"<p>Enables editing of the source attributes such as name, description, whether to allow markov requests, etc.</p> <p>Served at <code>app/sources/&lt;slug:source&gt;/edit/</code>.</p>"},{"location":"managing_quotes/#source-delete","title":"Source Delete","text":"<p>Enable deleting a source and all child data associated with it.</p> <p>Served at <code>app/sources/&lt;slug:source&gt;/delete/</code>.</p>"},{"location":"managing_quotes/#quote-list","title":"Quote List","text":"<p>Provides a paginated list of quotes created for the given :ref:<code>Source</code>.</p> <p>Served at <code>app/sources/&lt;slug:source&gt;/quotes/</code>.</p>"},{"location":"managing_quotes/#quote-create","title":"Quote Create","text":"<p>Add a quote for the given <code>Source</code>.</p> <p>Served at <code>app/sources/&lt;slug:source&gt;/quotes/create/</code>.</p>"},{"location":"managing_quotes/#quote-detail","title":"Quote Detail","text":"<p>Shows details of the quote including the HTML rendered version of the text, and in the future will also include statistical data.</p> <p>Served at <code>app/quotes/&lt;int:quote&gt;/</code>.</p>"},{"location":"managing_quotes/#quote-update","title":"Quote Update","text":"<p>Enables the user to update the quote text for a given <code>Quote</code> object.</p> <p>Served at <code>app/quotes/&lt;int:quote&gt;/edit/</code>.</p>"},{"location":"managing_quotes/#quote-delete","title":"Quote Delete","text":"<p>Enables the user to delete a given <code>Quote</code> object.</p> <p>Served at <code>app/quotes/&lt;int:quote&gt;/delete/</code>.</p>"},{"location":"managing_quotes/#signals","title":"Signals","text":"<p>There are two signals provided that are used to update statistics related to <code>SourceGroup</code>, <code>Source</code>, and <code>Quote</code> objects. If you implement your own methods and want to ensure your stats related to <code>quotes_requested</code> and <code>quotes_generated</code> remain accurate, you will need to send these.</p>"},{"location":"managing_quotes/#quote-retrieved","title":"Quote Retrieved","text":"<pre><code>django_quotes.signals.quote_random_retrieved.send(sender, instance, quote_retrieved, *args, **kwargs)\n</code></pre> <p>The <code>sender</code> should in most contexts be either <code>Source</code> or <code>SourceGroup</code> class definitions (not instances). The <code>instance</code> should be the actual instance of the <code>Source</code> that is being used.</p> <p>This signal will update the <code>quotes_retrieved</code> stats in the related <code>GroupStats</code>, <code>SourceStats</code>, and <code>QuoteStats</code> objects.</p>"},{"location":"managing_quotes/#quote-generated","title":"Quote Generated","text":"<pre><code>django_quotes.signals.markov_sentence_generated.send(sender, instance, *args, **kwargs)\n</code></pre> <p>The <code>sender</code> should in most contexts be either <code>Source</code> or <code>SourceGroup</code> class definitions (not instances). The <code>instance</code> should be the actual instance of the <code>Source</code> that is being used.</p> <p>This signal will update the <code>quotes_generated</code> stats in the related <code>GroupStats</code> and <code>SourceStats</code> objects.</p>"},{"location":"managing_quotes/#management-commands","title":"Management Commands","text":"<p><code>django-quotes</code> provides a management command you can use to check and generate new Markov models for both <code>SourceGroup</code> and <code>Source</code> objects.</p> <p><code>bash python manage.py makemarkov</code></p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Django-Quotes uses markovify in conjunction with natural language processing functions from spacy so installation and configuration requires some additional steps.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>First install <code>django-quotes</code> using a tool like pip.</p> \ud83c\udf89 Look, it's the way you install almost every library!<pre><code>pip install django-quotes\n</code></pre> <p>Because we're using <code>spacy</code>, we also need to download the language model we are using, which is <code>en_core_web_trf</code>.<sup>1</sup> While there are a number of ugly ways to annotate this process, it's safer for you to do the installation directly using the following command.</p> It's an extra step because academia.<pre><code>python -m spacy download en_core_web_trf\n</code></pre>"},{"location":"quickstart/#configuration","title":"Configuration","text":""},{"location":"quickstart/#application-settings","title":"Application Settings","text":"<p>Now we need to configure our Django project to use <code>django-quotes</code>. Because we provide object-based permissions and a REST API, you'll also need to enable Django REST Framework and django-rules. Unless you plan on overriding the included templates, you should also include <code>crispy-forms</code>.</p> settings.py<pre><code>   # Number of quotes to fetch when doing random selections from a single source.\n   # Optional. Default is 50.\n   MAX_QUOTES_FOR_RANDOM_SET = 50\n\n   # Number of quotes to fetch when doing random selections from a SourceGroup.\n   # Optional. Default is 50.\n   MAX_QUOTES_FOR_RANDOM_GROUP_SET = 50\n\n   INSTALLED_APPS = [\n        \"django.contrib.auth\",\n        \"django.contrib.contenttypes\",\n        \"django.contrib.sessions\",\n        \"django.contrib.sites\",\n        \"django.contrib.messages\",\n        \"django.contrib.staticfiles\",\n        # \"django.contrib.humanize\", # Handy template tags\n        \"django.contrib.admin\",\n        \"django.forms\",\n        \"crispy_forms\",\n        \"rest_framework\",\n        \"rest_framework.authtoken\",\n        \"corsheaders\",\n        \"drf_spectacular\",\n        \"rules.apps.AutodiscoverRulesConfig\",\n        \"django_quotes\",\n        # Your stuff: custom apps go here\n    ]\n\n    # AUTHENTICATION\n    # ------------------------------------------------------------------------------\n    # https://docs.djangoproject.com/en/dev/ref/settings/#authentication-backends\n    AUTHENTICATION_BACKENDS = [\n        \"rules.permissions.ObjectPermissionBackend\",\n        \"django.contrib.auth.backends.ModelBackend\",\n    ]\n\n    # MIDDLEWARE\n    # ------------------------------------------------------------------------------\n    # https://docs.djangoproject.com/en/dev/ref/settings/#middleware\n    MIDDLEWARE = [\n        \"django.middleware.security.SecurityMiddleware\",\n        \"corsheaders.middleware.CorsMiddleware\",\n        \"django.contrib.sessions.middleware.SessionMiddleware\",\n        \"django.middleware.locale.LocaleMiddleware\",\n        \"django.middleware.common.CommonMiddleware\",\n        \"django.middleware.csrf.CsrfViewMiddleware\",\n        \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n        \"django.contrib.messages.middleware.MessageMiddleware\",\n        \"django.middleware.common.BrokenLinkEmailsMiddleware\",\n        \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n    ]\n\n    # django-rest-framework\n    # -------------------------------------------------------------------------------\n    # django-rest-framework - https://www.django-rest-framework.org/api-guide/settings/\n    REST_FRAMEWORK = {\n        \"DEFAULT_AUTHENTICATION_CLASSES\": (\n            \"rest_framework.authentication.SessionAuthentication\",\n            \"rest_framework.authentication.TokenAuthentication\",\n        ),\n        \"DEFAULT_PERMISSION_CLASSES\": (\"rest_framework.permissions.IsAuthenticated\",),\n        \"DEFAULT_SCHEMA_CLASS\": \"drf_spectacular.openapi.AutoSchema\",\n    }\n\n    # django-cors-headers - https://github.com/adamchainz/django-cors-headers#setup\n    CORS_URLS_REGEX = r\"^/api/.*$\"\n\n    # By Default swagger ui is available only to admin user. You can change permission classs to change that\n    # See more configuration options at https://drf-spectacular.readthedocs.io/en/latest/settings.html#settings\n    SPECTACULAR_SETTINGS = {\n        \"TITLE\": \"Django Quotes API\",\n        \"DESCRIPTION\": \"Documentation of API endpoints of Django Quotes\",\n        \"VERSION\": \"1.0.0\",\n        \"SERVE_PERMISSIONS\": [\"rest_framework.permissions.IsAdminUser\"],\n        \"SERVERS\": [\n            {\"url\": \"https://127.0.0.1:8000\", \"description\": \"Local Development server\"},\n        ],\n    }\n</code></pre>"},{"location":"quickstart/#url-settings","title":"URL Settings","text":"<p>First, configure your API router.</p> api_router.py<pre><code>from django.conf import settings\nfrom rest_framework.routers import DefaultRouter, SimpleRouter\n\nfrom django_quotes.api.views import SourceGroupViewSet, SourceViewSet\n\nif settings.DEBUG:\n    router = DefaultRouter()\nelse:\n    router = SimpleRouter()\n\nrouter.register(\"groups\", SourceGroupViewSet, basename=\"group\")\nrouter.register(\"sources\", SourceViewSet, basename=\"source\")\n\n\napp_name = \"api\"\nurlpatterns = router.urls\n</code></pre> <p>Then you will need to wire up the views to your project URLs configuration as displayed below.</p> urls.py<pre><code>urlpatterns = [\n    # Chose whatever path your want, but keep the namespace as ``quotes``.\n    path(\"app/\", include(\"django_quotes.urls\", namespace=\"quotes\")),\n    # API base url. You can change this path if you like.\n    path(\"api/\", include(\"path.to.your.api_router\")),\n    # DRF auth token\n    path(\"auth-token/\", obtain_auth_token),\n    path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"api-schema\"),\n    path(\n        \"api/docs/\",\n        SpectacularSwaggerView.as_view(url_name=\"api-schema\"),\n        name=\"api-docs\",\n    ),\n    # Insert your other URLS here.\n]\n</code></pre>"},{"location":"quickstart/#customizing-templates-optional","title":"Customizing Templates (Optional)","text":"<p>If you want to override the existing templates, you can. By default they are Bootstrap 5-compatible, although we do not bundle Bootstrap within the project. To override, create a <code>templates/quotes</code> directory in your project and add the following templates:</p> <pre><code>ls django_quotes/templates/quotes\n\ngroup_create.html\ngroup_delete.html\ngroup_detail.html\ngroup_list.html\ngroup_update.html\nquote_create.html\nquote_delete.html\nquote_detail.html\nquote_list.html\nquote_update.html\nsource_create.html\nsource_delete.html\nsource_detail.html\nsource_list.html\nsource_update.html\n</code></pre>"},{"location":"quickstart/#usage","title":"Usage","text":"<p>By default, django-quotes provides access via the admin site, and provides a set of basic views for managing the quotes and associated data. See Managing Quotes for more information.</p> <ol> <li> <p>Other languages are not supported at this time.\u00a0\u21a9</p> </li> </ol>"},{"location":"security/","title":"Security","text":""},{"location":"security/#security","title":"Security","text":""},{"location":"security/#reporting-security-issues","title":"\ud83d\udd10 Reporting Security Issues","text":"<p>Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge.</p> <p>Vulnerabilities can be reported by emailing core members:</p> <ul> <li>Daniel Andrlik daniel@andrlik.org</li> </ul> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Environment (e.g. Linux / Windows / macOS)</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p>"},{"location":"security/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"}]}