{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Quotes A simple reusable Django app that allows you to collect quotes from arbitrary groups of characters, and then serve random quotes or Markov-chain generated sentences based upon them. Includes a Bootstrap compatible set of templates an optional REST API. Features Documentation and a full test suite. Support for abstract grouping of quote sources. Convenience methods for fetching a random quote. Object-level permissions via django-rules . Generate sentences based off of a Markov-chain for individual sources and groups using natural language processing. Bootstrap-compatible templates. A simple REST API for fetching data via JSON with CORS support. Check out the documentation for installation and quickstart instructions.","title":"Home"},{"location":"#django-quotes","text":"A simple reusable Django app that allows you to collect quotes from arbitrary groups of characters, and then serve random quotes or Markov-chain generated sentences based upon them. Includes a Bootstrap compatible set of templates an optional REST API.","title":"Django Quotes"},{"location":"#features","text":"Documentation and a full test suite. Support for abstract grouping of quote sources. Convenience methods for fetching a random quote. Object-level permissions via django-rules . Generate sentences based off of a Markov-chain for individual sources and groups using natural language processing. Bootstrap-compatible templates. A simple REST API for fetching data via JSON with CORS support. Check out the documentation for installation and quickstart instructions.","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at daniel@andrlik.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at daniel@andrlik.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/","text":"How to contribute Dependencies We use poetry to manage the dependencies . If you dont have poetry , you should install with make poetry-download . To install dependencies and prepare pre-commit hooks you would need to run install command: make install make pre-commit-install To activate your virtualenv run poetry shell . Codestyle After installation you may execute code formatting. make codestyle Checks Many checks are configured for this project. Command make check-codestyle will check black, isort and darglint. The make check-safety command will look at the security of your code. Comand make lint applies all checks. Before submitting Before submitting your code please do the following steps: Add any changes you want Add tests for the new changes Edit documentation if you have changed something significant Run make codestyle to format your changes. Run make lint to ensure that types, security and docstrings are okay. Add your name to the CONTRIBUTERS.txt file. Other help You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"","title":"How to contribute"},{"location":"contributing/#dependencies","text":"We use poetry to manage the dependencies . If you dont have poetry , you should install with make poetry-download . To install dependencies and prepare pre-commit hooks you would need to run install command: make install make pre-commit-install To activate your virtualenv run poetry shell .","title":"Dependencies"},{"location":"contributing/#codestyle","text":"After installation you may execute code formatting. make codestyle","title":"Codestyle"},{"location":"contributing/#checks","text":"Many checks are configured for this project. Command make check-codestyle will check black, isort and darglint. The make check-safety command will look at the security of your code. Comand make lint applies all checks.","title":"Checks"},{"location":"contributing/#before-submitting","text":"Before submitting your code please do the following steps: Add any changes you want Add tests for the new changes Edit documentation if you have changed something significant Run make codestyle to format your changes. Run make lint to ensure that types, security and docstrings are okay. Add your name to the CONTRIBUTERS.txt file.","title":"Before submitting"},{"location":"contributing/#other-help","text":"You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.","title":"Other help"},{"location":"managing_quotes/","text":"Django-Quotes uses a number of rudimentary data models with basic scaffolding views to manage the data. User-based permissions are used to control access to the data. Models Source Group An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to the same group. For example, a novel or series if you plan to quote the characters within individually. Attributes: Name Type Description id int Database primary key for the object. name str Human readable string to name the group. This will be converted to a slug prefix. description str A description of the group for convenience. Markdown can be used here for styling. description_rendered str The HTML representation of the description string. Generated automatically. owner User The user that created the group and therefore owns it. public bool Is this group public or private. Defaults to False. allow_submissions bool Allow other users to submit characters to this. Not yet implemented. slug str A unique slug to represent this group. Generated automatically from name. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class SourceGroup ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to the same group. For example, a novel or series if you plan to quote the characters within individually. Attributes: id (int): Database primary key for the object. name (str): Human readable string to name the group. This will be converted to a slug prefix. description (str): A description of the group for convenience. Markdown can be used here for styling. description_rendered (str): The HTML representation of the description string. Generated automatically. owner (User): The user that created the group and therefore owns it. public (bool): Is this group public or private. Defaults to False. allow_submissions (bool): Allow other users to submit characters to this. Not yet implemented. slug (str): A unique slug to represent this group. Generated automatically from name. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" name = models . CharField ( _ ( \"Source Name\" ), max_length = 50 , help_text = _ ( \"A source for individuals making the quotes. Use as an abstract grouping.\" ), db_index = True , ) description = models . TextField ( help_text = _ ( \"Description for the source. You can style using Markdown.\" ), null = True , blank = True , ) description_rendered = models . TextField ( help_text = _ ( \"Automatically generated from description\" ), null = True , blank = True ) slug = models . SlugField ( unique = True , max_length = 70 , editable = False , blank = True , help_text = _ ( \"Unique slug for this group.\" ), ) @cached_property def total_sources ( self ) -> int : return Source . objects . filter ( group = self ) . count () @cached_property def markov_sources ( self ) -> int : return Source . objects . filter ( group = self , allow_markov = True ) . count () @cached_property def total_quotes ( self ) -> int : return Quote . objects . filter ( source__in = Source . objects . filter ( group = self ) ) . count () @cached_property def markov_ready ( self ) -> bool : if ( self . markov_sources > 0 and Quote . objects . filter ( source__in = self . source_set . filter ( allow_markov = True ) ) . count () > 10 ): return True return False def generate_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> str | None : \"\"\" Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None \"\"\" if self . markov_ready : logger . debug ( \"Group is ready for markov sentences. Checking model...\" ) mmodel = GroupMarkovModel . objects . get ( group = self ) if mmodel . data is None : logger . debug ( \"Markov model for group is not generated yet! Generating...\" ) mmodel . generate_model_from_corpus () logger . debug ( \"Loading text model...\" ) text_model = MarkovPOSText . from_json ( mmodel . data ) logger . debug ( \"Generating sentence...\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : logger . debug ( f \"Returning generated sentence: ' { sentence } '\" ) return sentence logger . debug ( \"Group is not ready for markov requests yet!\" ) return None def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_GROUP_SET ) -> Any : \"\"\" Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: ``Quote`` object or None if no quotes are defined. \"\"\" quotes = ( Quote . objects . filter ( source__in = self . source_set . all ()) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes . exists (): quote = random . choice ( list ( quotes )) quote_random_retrieved . send ( type ( quote . source ), instance = quote . source , quote_retrieved = quote ) return quote return None def refresh_from_db ( self , * args , ** kwargs ): super () . refresh_from_db ( * args , ** kwargs ) cached_properties = [ \"total_sources\" , \"markov_sources\" , \"total_quotes\" ] for prop in cached_properties : try : del self . __dict__ [ prop ] except KeyError : # pragma: nocover pass def save ( self , * args , ** kwargs ): if ( not self . slug ): # Once this slug is set, it does not change except through devil pacts logger . debug ( \"Group is being saved and a slug was provided.\" ) self . slug = generate_unique_slug_for_model ( model_class = type ( self ), text = self . name ) super () . save ( * args , ** kwargs ) def __str__ ( self ): # pragma: nocover return self . name class Meta : rules_permissions = { \"add\" : rules . is_authenticated , \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , } ordering = [ \"name\" ] generate_markov_sentence ( self , max_characters = 280 ) Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None Source code in django_quotes/models.py def generate_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> str | None : \"\"\" Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None \"\"\" if self . markov_ready : logger . debug ( \"Group is ready for markov sentences. Checking model...\" ) mmodel = GroupMarkovModel . objects . get ( group = self ) if mmodel . data is None : logger . debug ( \"Markov model for group is not generated yet! Generating...\" ) mmodel . generate_model_from_corpus () logger . debug ( \"Loading text model...\" ) text_model = MarkovPOSText . from_json ( mmodel . data ) logger . debug ( \"Generating sentence...\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : logger . debug ( f \"Returning generated sentence: ' { sentence } '\" ) return sentence logger . debug ( \"Group is not ready for markov requests yet!\" ) return None get_random_quote ( self , max_quotes_to_process = 50 ) Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: Quote object or None if no quotes are defined. Source code in django_quotes/models.py def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_GROUP_SET ) -> Any : \"\"\" Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: ``Quote`` object or None if no quotes are defined. \"\"\" quotes = ( Quote . objects . filter ( source__in = self . source_set . all ()) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes . exists (): quote = random . choice ( list ( quotes )) quote_random_retrieved . send ( type ( quote . source ), instance = quote . source , quote_retrieved = quote ) return quote return None Source An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific author. Attributes: Name Type Description id int Database primary key for the object. name str Unique name of a character within a CharacterGroup for this entity. group SourceGroup The parent SourceGroup . slug str Slug made up of a generated version of the character name and the group slug prefix. description str Description for the character. Markdown can be used for styling. description_rendered str HTML representation of the description for convenience. Automatically generated. allow_markov bool Allow markov quotes to be requested from this character? Default False. owner User The user that created and owns this character. public bool Is the character public to other users? Defaults to False. allow_submissions bool Allow other users to submit quotes for this character? Defaults to False. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class Source ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific author. Attributes: id (int): Database primary key for the object. name (str): Unique name of a character within a ``CharacterGroup`` for this entity. group (SourceGroup): The parent ``SourceGroup``. slug (str): Slug made up of a generated version of the character name and the group slug prefix. description (str): Description for the character. Markdown can be used for styling. description_rendered (str): HTML representation of the description for convenience. Automatically generated. allow_markov (bool): Allow markov quotes to be requested from this character? Default False. owner (User): The user that created and owns this character. public (bool): Is the character public to other users? Defaults to False. allow_submissions (bool): Allow other users to submit quotes for this character? Defaults to False. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" name = models . CharField ( max_length = 100 , help_text = _ ( \"Name of the character\" )) slug = models . SlugField ( max_length = 250 , help_text = _ ( \"Global slug of the character, will be auto generated from name and group if not overridden.\" ), blank = True , editable = False , unique = True , db_index = True , ) description = models . TextField ( null = True , blank = True , help_text = _ ( \"Description of this character. You can style this with Markdown.\" ), ) description_rendered = models . TextField ( null = True , blank = True , help_text = _ ( \"Automatically generated from description.\" ) ) allow_markov = models . BooleanField ( default = False , help_text = _ ( \"Allow to be used in markov chains?\" ) ) group = models . ForeignKey ( SourceGroup , on_delete = models . CASCADE , help_text = _ ( \"The group this character belongs to.\" ), ) @property def markov_ready ( self ) -> bool : \"\"\" Conducts sanity checks to see if requesting a markov chain is feasible. Markov must be enabled for a character and there must be a sufficient corpus to generate a sentence from. Currently set at a minimum of 10 quotes. :return: bool \"\"\" if self . allow_markov and Quote . objects . filter ( source = self ) . count () > 10 : return True return False def get_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> Optional [ str ]: \"\"\" If valid, generate a markov sentence. If not, return None. :param max_characters: Optional maximum limit of characters in the return set. Default: 280 :return: str or None \"\"\" logger . debug ( \"Checking to see if character is markov ready...\" ) if self . markov_ready : logger . debug ( \"It IS ready. Fetching markov model.\" ) markov_model = SourceMarkovModel . objects . get ( source = self ) if not markov_model . data : logger . debug ( \"No model defined yet, generating...\" ) markov_model . generate_model_from_corpus () text_model = MarkovPOSText . from_json ( markov_model . data ) logger . debug ( \"Markov text model loaded. Generating sentence.\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : markov_sentence_generated . send ( type ( self ), instance = self ) return sentence return None def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_SET ) -> Optional [ Any ]: \"\"\" This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: ``Quote`` object or None \"\"\" quotes_to_pick = ( Quote . objects . filter ( source = self ) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes_to_pick . exists (): # Select a random index in the result set. quote_to_return = random . choice ( list ( quotes_to_pick )) quote_random_retrieved . send ( type ( self ), instance = self , quote_retrieved = quote_to_return ) return quote_to_return return None def __str__ ( self ): # pragma: nocover return self . name def save ( self , * args , ** kwargs ): if not self . slug : self . slug = generate_unique_slug_for_model ( type ( self ), text = f \" { self . group . slug } { self . name } \" ) super () . save ( * args , ** kwargs ) class Meta : rules_permissions = { \"add\" : rules . is_authenticated , \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , } get_random_quote ( self , max_quotes_to_process = 50 ) This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: Quote object or None Source code in django_quotes/models.py def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_SET ) -> Optional [ Any ]: \"\"\" This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: ``Quote`` object or None \"\"\" quotes_to_pick = ( Quote . objects . filter ( source = self ) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes_to_pick . exists (): # Select a random index in the result set. quote_to_return = random . choice ( list ( quotes_to_pick )) quote_random_retrieved . send ( type ( self ), instance = self , quote_retrieved = quote_to_return ) return quote_to_return return None Quote A quote from a given source. Attributes: Name Type Description id int Database primary key for the object. quote str The quote text to use. You can use Markdown for styling. Must be <= 280 characters for tweets quote_rendered str HTML rendered version of the quote field. Automatically generated. citation str Optional description of quote source, e.g. episode number or book title. citation_url str Optional accompanying URL for the citation. character Source The source of this quote. owner User The user that created and owns this quote. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class Quote ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" A quote from a given source. Attributes: id (int): Database primary key for the object. quote (str): The quote text to use. You can use Markdown for styling. Must be <= 280 characters for tweets quote_rendered (str): HTML rendered version of the quote field. Automatically generated. citation (str): Optional description of quote source, e.g. episode number or book title. citation_url (str): Optional accompanying URL for the citation. character (Source): The source of this quote. owner (User): The user that created and owns this quote. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" quote = models . CharField ( max_length = 280 , # Keep the base limit to 280 so that quotes are 'tweetable' help_text = \"Plain text representation of quote. You can use Markdown here.\" , ) quote_rendered = models . TextField ( null = True , blank = True , help_text = _ ( \"HTML rendered version of quote generated from quote plain text.\" ), ) source = models . ForeignKey ( Source , on_delete = models . CASCADE , help_text = _ ( \"The source of this quote, i.e. name.\" ), ) citation = models . CharField ( max_length = 250 , blank = True , null = True , help_text = _ ( \"Where is this quote from? Episode #, book?\" ), ) citation_url = models . URLField ( null = True , blank = True , help_text = _ ( \"URL for citation, if applicable.\" ) ) def __str__ ( self ): # pragma: nocover return f \" { self . source . name } : { self . quote } \" class Meta : rules_permissions = { # \"add\": is_character_owner, \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , } Source Markov Model The cached markov model for a given source. The database object for this is automatically created whenever a new character object is saved. Attributes: Name Type Description id int Database primary key for the object. source Source The character who the model is sourced from. data json The JSON representation of the Markov model created by markovify . created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class SourceMarkovModel ( TimeStampedModel ): \"\"\" The cached markov model for a given source. The database object for this is automatically created whenever a new character object is saved. Attributes: id (int): Database primary key for the object. source (Source): The character who the model is sourced from. data (json): The JSON representation of the Markov model created by ``markovify``. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" source = models . OneToOneField ( Source , on_delete = models . CASCADE ) data = models . JSONField ( null = True , blank = True ) def generate_model_from_corpus ( self ): \"\"\" Collect all quotes attributed to the related character. Then create, compile, and save the model. \"\"\" logger . debug ( \"Generating text model. Fetching quotes.\" ) quotes = Quote . objects . filter ( source = self . source ) # Don't bother generating model if there isn't data. if not quotes . exists (): # pragma: nocover logger . debug ( \"There are no quotes. Returning None.\" ) return logger . debug ( \"Quotes retrieved! Forming into corpus.\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Building text model.\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model.\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving model as JSON.\" ) self . data = text_model . to_json () self . save () logger . debug ( \"Markov model populated to database.\" ) def __str__ ( self ): # pragma: nocover return self . source . name generate_model_from_corpus ( self ) Collect all quotes attributed to the related character. Then create, compile, and save the model. Source code in django_quotes/models.py def generate_model_from_corpus ( self ): \"\"\" Collect all quotes attributed to the related character. Then create, compile, and save the model. \"\"\" logger . debug ( \"Generating text model. Fetching quotes.\" ) quotes = Quote . objects . filter ( source = self . source ) # Don't bother generating model if there isn't data. if not quotes . exists (): # pragma: nocover logger . debug ( \"There are no quotes. Returning None.\" ) return logger . debug ( \"Quotes retrieved! Forming into corpus.\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Building text model.\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model.\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving model as JSON.\" ) self . data = text_model . to_json () self . save () logger . debug ( \"Markov model populated to database.\" ) Group Markov Model The cached markov model for the entire group. It is made up of every quote from every markov enabled character within the group. Attributes: Name Type Description id int The database id of this object. group SourceGroup The OneToOne relationship to SourceGroup data json The cached markov model. created datetime When the object was created. modified datetime When the object was last modified. Source code in django_quotes/models.py class GroupMarkovModel ( TimeStampedModel ): \"\"\" The cached markov model for the entire group. It is made up of every quote from every markov enabled character within the group. Attributes: id (int): The database id of this object. group (SourceGroup): The OneToOne relationship to ``SourceGroup`` data (json): The cached markov model. created (datetime): When the object was created. modified (datetime): When the object was last modified. \"\"\" group = models . OneToOneField ( SourceGroup , on_delete = models . CASCADE , help_text = _ ( \"The character group this model belongs to.\" ), ) data = models . JSONField ( null = True , blank = True , help_text = _ ( \"The cached markov model as JSON.\" ) ) def generate_model_from_corpus ( self ): \"\"\" Collect all quotes from markov enabled characters in this group and then compile the model and save it. \"\"\" logger . debug ( f \"Gathering corpus for character group: { self . group . name } \" ) quotes = Quote . objects . filter ( source__in = Source . objects . filter ( group = self . group , allow_markov = True ) ) if quotes . exists (): if quotes . count () >= 10 : logger . debug ( \"Found sufficient quotes for a model!\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Forming text model...\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model...\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving compiled model to JSON...\" ) self . data = text_model . to_json () self . save () logger . debug ( f \"Finished building and saving group markov model for { self . group . name } !\" ) generate_model_from_corpus ( self ) Collect all quotes from markov enabled characters in this group and then compile the model and save it. Source code in django_quotes/models.py def generate_model_from_corpus ( self ): \"\"\" Collect all quotes from markov enabled characters in this group and then compile the model and save it. \"\"\" logger . debug ( f \"Gathering corpus for character group: { self . group . name } \" ) quotes = Quote . objects . filter ( source__in = Source . objects . filter ( group = self . group , allow_markov = True ) ) if quotes . exists (): if quotes . count () >= 10 : logger . debug ( \"Found sufficient quotes for a model!\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Forming text model...\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model...\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving compiled model to JSON...\" ) self . data = text_model . to_json () self . save () logger . debug ( f \"Finished building and saving group markov model for { self . group . name } !\" ) Group Stats An object for using to track usage stats for CharacterGroup . Attributes: Name Type Description group SourceGroup The group this is collecting stats for. quotes_requested int The number of times a quote from this object or its children has been requested. quotes_generated int The number of times a markov quote has been generated for this or it's children. Source code in django_quotes/models.py class GroupStats ( TimeStampedModel ): \"\"\" An object for using to track usage stats for ``CharacterGroup``. Attributes: group (SourceGroup): The group this is collecting stats for. quotes_requested (int): The number of times a quote from this object or its children has been requested. quotes_generated (int): The number of times a markov quote has been generated for this or it's children. \"\"\" group = models . OneToOneField ( SourceGroup , related_name = \"stats\" , on_delete = models . CASCADE ) quotes_requested = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of time child quotes have been requested.\" ) ) quotes_generated = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of times markov generated quotes have been requested.\" ), ) Source Stats An object for using to track usage stats for Character . Attributes: Name Type Description source Source The source this is collecting stats for. quotes_requested int The number of times a quote from this object or its children has been requested. quotes_generated int The number of times a markov quote has been generated for this or it's children. Source code in django_quotes/models.py class SourceStats ( TimeStampedModel ): \"\"\" An object for using to track usage stats for ``Character``. Attributes: source (Source): The source this is collecting stats for. quotes_requested (int): The number of times a quote from this object or its children has been requested. quotes_generated (int): The number of times a markov quote has been generated for this or it's children. \"\"\" source = models . OneToOneField ( Source , related_name = \"stats\" , on_delete = models . CASCADE ) quotes_requested = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of time child quotes have been requested.\" ) ) quotes_generated = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of times markov generated quotes have been requested.\" ), ) Quote Stats A simple object used to track how often an individual quote is used. Attributes: Name Type Description id int The database primary key of this object. quote Quote The quote this stat relates to. times_used int The number of times this has been used by an service such as random quote. created datetime When this was created. modified datetime When this was last modified. Source code in django_quotes/models.py class QuoteStats ( TimeStampedModel ): \"\"\" A simple object used to track how often an individual quote is used. Attributes: id (int): The database primary key of this object. quote (Quote): The quote this stat relates to. times_used (int): The number of times this has been used by an service such as random quote. created (datetime): When this was created. modified (datetime): When this was last modified. \"\"\" quote = models . OneToOneField ( Quote , on_delete = models . CASCADE , related_name = \"stats\" , help_text = _ ( \"The Quote the stats related to.\" ), ) times_used = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Times used for random quotes, etc.\" ) ) def __str__ ( self ): # pragma: nocover return f \"Stats for Quote { self . quote . id } \" Views The core views for managing the quotes consist of simple data entry and manipulation functions, heavily utilizing Django's generic views. All views require login. Source Group List Provides a paginated list of source groups created by logged in user. Served at /app/groups/ . Source Group Create Allows a user to define a new SourceGroup . Served at app/groups/create/ . Source Group Detail Displays a detailed view of a source group with a sampling of the :ref: Source objects associated, with links to full listings. Served at app/groups/<slug:group>/ . Source Group Update Allows user to update the source group's attributes. Served at app/groups/<slug:group>/edit/ . Source Group Delete Allows user to delete a SourceGroup and all child data associated with it. Served at app/groups/<slug:group>/delete/ . Source List Paginated list of all the :ref: Source objects associated with a given group, along with aggregate statistics such as total quotes. Served at app/groups/<slug:group>/sources/ . Source Create Enables a user to create a new Source for a given SourceGroup . Served at app/groups/<slug:group>/sources/create/ . Source Detail Detail view of the :ref: Source object including a sampling of recently created/modified quotes with links to full listings. Served at app/sources/<slug:source>/ . Source Update Enables editing of the source attributes such as name, description, whether to allow markov requests, etc. Served at app/sources/<slug:source>/edit/ . Source Delete Enable deleting a source and all child data associated with it. Served at app/sources/<slug:source>/delete/ . Quote List Provides a paginated list of quotes created for the given :ref: Source . Served at app/sources/<slug:source>/quotes/ . Quote Create Add a quote for the given Source . Served at app/sources/<slug:source>/quotes/create/ . Quote Detail Shows details of the quote including the HTML rendered version of the text, and in the future will also include statistical data. Served at app/quotes/<int:quote>/ . Quote Update Enables the user to update the quote text for a given Quote object. Served at app/quotes/<int:quote>/edit/ . Quote Delete Enables the user to delete a given Quote object. Served at app/quotes/<int:quote>/delete/ . Signals There are two signals provided that are used to update statistics related to SourceGroup , Source , and Quote objects. If you implement your own methods and want to ensure your stats related to quotes_requested and quotes_generated remain accurate, you will need to send these. Quote Retrieved django_quotes . signals . quote_random_retrieved . send ( sender , instance , quote_retrieved , * args , ** kwargs ) The sender should in most contexts be either Source or SourceGroup class definitions ( not instances ). The instance should be the actual instance of the Source that is being used. This signal will update the quotes_retrieved stats in the related GroupStats , SourceStats , and QuoteStats objects. Quote Generated django_quotes . signals . markov_sentence_generated . send ( sender , instance , * args , ** kwargs ) The sender should in most contexts be either Source or SourceGroup class definitions ( not instances ). The instance should be the actual instance of the Source that is being used. This signal will update the quotes_generated stats in the related GroupStats and SourceStats objects. Management Commands django-quotes provides a management command you can use to check and generate new Markov models for both SourceGroup and Source objects. bash python manage.py makemarkov","title":"Managing Sources & Quotes"},{"location":"managing_quotes/#models","text":"","title":"Models"},{"location":"managing_quotes/#source-group","text":"An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to the same group. For example, a novel or series if you plan to quote the characters within individually. Attributes: Name Type Description id int Database primary key for the object. name str Human readable string to name the group. This will be converted to a slug prefix. description str A description of the group for convenience. Markdown can be used here for styling. description_rendered str The HTML representation of the description string. Generated automatically. owner User The user that created the group and therefore owns it. public bool Is this group public or private. Defaults to False. allow_submissions bool Allow other users to submit characters to this. Not yet implemented. slug str A unique slug to represent this group. Generated automatically from name. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class SourceGroup ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" An abstract group or source for a given set of quotes. Multiple sources, or Source objects, can belong to the same group. For example, a novel or series if you plan to quote the characters within individually. Attributes: id (int): Database primary key for the object. name (str): Human readable string to name the group. This will be converted to a slug prefix. description (str): A description of the group for convenience. Markdown can be used here for styling. description_rendered (str): The HTML representation of the description string. Generated automatically. owner (User): The user that created the group and therefore owns it. public (bool): Is this group public or private. Defaults to False. allow_submissions (bool): Allow other users to submit characters to this. Not yet implemented. slug (str): A unique slug to represent this group. Generated automatically from name. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" name = models . CharField ( _ ( \"Source Name\" ), max_length = 50 , help_text = _ ( \"A source for individuals making the quotes. Use as an abstract grouping.\" ), db_index = True , ) description = models . TextField ( help_text = _ ( \"Description for the source. You can style using Markdown.\" ), null = True , blank = True , ) description_rendered = models . TextField ( help_text = _ ( \"Automatically generated from description\" ), null = True , blank = True ) slug = models . SlugField ( unique = True , max_length = 70 , editable = False , blank = True , help_text = _ ( \"Unique slug for this group.\" ), ) @cached_property def total_sources ( self ) -> int : return Source . objects . filter ( group = self ) . count () @cached_property def markov_sources ( self ) -> int : return Source . objects . filter ( group = self , allow_markov = True ) . count () @cached_property def total_quotes ( self ) -> int : return Quote . objects . filter ( source__in = Source . objects . filter ( group = self ) ) . count () @cached_property def markov_ready ( self ) -> bool : if ( self . markov_sources > 0 and Quote . objects . filter ( source__in = self . source_set . filter ( allow_markov = True ) ) . count () > 10 ): return True return False def generate_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> str | None : \"\"\" Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None \"\"\" if self . markov_ready : logger . debug ( \"Group is ready for markov sentences. Checking model...\" ) mmodel = GroupMarkovModel . objects . get ( group = self ) if mmodel . data is None : logger . debug ( \"Markov model for group is not generated yet! Generating...\" ) mmodel . generate_model_from_corpus () logger . debug ( \"Loading text model...\" ) text_model = MarkovPOSText . from_json ( mmodel . data ) logger . debug ( \"Generating sentence...\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : logger . debug ( f \"Returning generated sentence: ' { sentence } '\" ) return sentence logger . debug ( \"Group is not ready for markov requests yet!\" ) return None def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_GROUP_SET ) -> Any : \"\"\" Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: ``Quote`` object or None if no quotes are defined. \"\"\" quotes = ( Quote . objects . filter ( source__in = self . source_set . all ()) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes . exists (): quote = random . choice ( list ( quotes )) quote_random_retrieved . send ( type ( quote . source ), instance = quote . source , quote_retrieved = quote ) return quote return None def refresh_from_db ( self , * args , ** kwargs ): super () . refresh_from_db ( * args , ** kwargs ) cached_properties = [ \"total_sources\" , \"markov_sources\" , \"total_quotes\" ] for prop in cached_properties : try : del self . __dict__ [ prop ] except KeyError : # pragma: nocover pass def save ( self , * args , ** kwargs ): if ( not self . slug ): # Once this slug is set, it does not change except through devil pacts logger . debug ( \"Group is being saved and a slug was provided.\" ) self . slug = generate_unique_slug_for_model ( model_class = type ( self ), text = self . name ) super () . save ( * args , ** kwargs ) def __str__ ( self ): # pragma: nocover return self . name class Meta : rules_permissions = { \"add\" : rules . is_authenticated , \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , } ordering = [ \"name\" ]","title":"Source Group"},{"location":"managing_quotes/#django_quotes.models.SourceGroup.generate_markov_sentence","text":"Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None Source code in django_quotes/models.py def generate_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> str | None : \"\"\" Generate a markov sentence based on quotes from markov enabled characters for the group. :return: str or None \"\"\" if self . markov_ready : logger . debug ( \"Group is ready for markov sentences. Checking model...\" ) mmodel = GroupMarkovModel . objects . get ( group = self ) if mmodel . data is None : logger . debug ( \"Markov model for group is not generated yet! Generating...\" ) mmodel . generate_model_from_corpus () logger . debug ( \"Loading text model...\" ) text_model = MarkovPOSText . from_json ( mmodel . data ) logger . debug ( \"Generating sentence...\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : logger . debug ( f \"Returning generated sentence: ' { sentence } '\" ) return sentence logger . debug ( \"Group is not ready for markov requests yet!\" ) return None","title":"generate_markov_sentence()"},{"location":"managing_quotes/#django_quotes.models.SourceGroup.get_random_quote","text":"Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: Quote object or None if no quotes are defined. Source code in django_quotes/models.py def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_GROUP_SET ) -> Any : \"\"\" Get a random quote object from any of the characters defined within the group. Prioritizes quotes that have been returned less often. :return: ``Quote`` object or None if no quotes are defined. \"\"\" quotes = ( Quote . objects . filter ( source__in = self . source_set . all ()) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes . exists (): quote = random . choice ( list ( quotes )) quote_random_retrieved . send ( type ( quote . source ), instance = quote . source , quote_retrieved = quote ) return quote return None","title":"get_random_quote()"},{"location":"managing_quotes/#source","text":"An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific author. Attributes: Name Type Description id int Database primary key for the object. name str Unique name of a character within a CharacterGroup for this entity. group SourceGroup The parent SourceGroup . slug str Slug made up of a generated version of the character name and the group slug prefix. description str Description for the character. Markdown can be used for styling. description_rendered str HTML representation of the description for convenience. Automatically generated. allow_markov bool Allow markov quotes to be requested from this character? Default False. owner User The user that created and owns this character. public bool Is the character public to other users? Defaults to False. allow_submissions bool Allow other users to submit quotes for this character? Defaults to False. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class Source ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" An individual source to attribute the quote to in the system, such as a character from a podcast/book, or a specific author. Attributes: id (int): Database primary key for the object. name (str): Unique name of a character within a ``CharacterGroup`` for this entity. group (SourceGroup): The parent ``SourceGroup``. slug (str): Slug made up of a generated version of the character name and the group slug prefix. description (str): Description for the character. Markdown can be used for styling. description_rendered (str): HTML representation of the description for convenience. Automatically generated. allow_markov (bool): Allow markov quotes to be requested from this character? Default False. owner (User): The user that created and owns this character. public (bool): Is the character public to other users? Defaults to False. allow_submissions (bool): Allow other users to submit quotes for this character? Defaults to False. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" name = models . CharField ( max_length = 100 , help_text = _ ( \"Name of the character\" )) slug = models . SlugField ( max_length = 250 , help_text = _ ( \"Global slug of the character, will be auto generated from name and group if not overridden.\" ), blank = True , editable = False , unique = True , db_index = True , ) description = models . TextField ( null = True , blank = True , help_text = _ ( \"Description of this character. You can style this with Markdown.\" ), ) description_rendered = models . TextField ( null = True , blank = True , help_text = _ ( \"Automatically generated from description.\" ) ) allow_markov = models . BooleanField ( default = False , help_text = _ ( \"Allow to be used in markov chains?\" ) ) group = models . ForeignKey ( SourceGroup , on_delete = models . CASCADE , help_text = _ ( \"The group this character belongs to.\" ), ) @property def markov_ready ( self ) -> bool : \"\"\" Conducts sanity checks to see if requesting a markov chain is feasible. Markov must be enabled for a character and there must be a sufficient corpus to generate a sentence from. Currently set at a minimum of 10 quotes. :return: bool \"\"\" if self . allow_markov and Quote . objects . filter ( source = self ) . count () > 10 : return True return False def get_markov_sentence ( self , max_characters : Optional [ int ] = 280 ) -> Optional [ str ]: \"\"\" If valid, generate a markov sentence. If not, return None. :param max_characters: Optional maximum limit of characters in the return set. Default: 280 :return: str or None \"\"\" logger . debug ( \"Checking to see if character is markov ready...\" ) if self . markov_ready : logger . debug ( \"It IS ready. Fetching markov model.\" ) markov_model = SourceMarkovModel . objects . get ( source = self ) if not markov_model . data : logger . debug ( \"No model defined yet, generating...\" ) markov_model . generate_model_from_corpus () text_model = MarkovPOSText . from_json ( markov_model . data ) logger . debug ( \"Markov text model loaded. Generating sentence.\" ) sentence : str | None = text_model . make_short_sentence ( max_chars = max_characters ) if sentence is not None : markov_sentence_generated . send ( type ( self ), instance = self ) return sentence return None def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_SET ) -> Optional [ Any ]: \"\"\" This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: ``Quote`` object or None \"\"\" quotes_to_pick = ( Quote . objects . filter ( source = self ) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes_to_pick . exists (): # Select a random index in the result set. quote_to_return = random . choice ( list ( quotes_to_pick )) quote_random_retrieved . send ( type ( self ), instance = self , quote_retrieved = quote_to_return ) return quote_to_return return None def __str__ ( self ): # pragma: nocover return self . name def save ( self , * args , ** kwargs ): if not self . slug : self . slug = generate_unique_slug_for_model ( type ( self ), text = f \" { self . group . slug } { self . name } \" ) super () . save ( * args , ** kwargs ) class Meta : rules_permissions = { \"add\" : rules . is_authenticated , \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , }","title":"Source"},{"location":"managing_quotes/#django_quotes.models.Source.get_random_quote","text":"This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: Quote object or None Source code in django_quotes/models.py def get_random_quote ( self , max_quotes_to_process : Optional [ int ] = MAX_QUOTES_FOR_RANDOM_SET ) -> Optional [ Any ]: \"\"\" This actually not all that random. It's going to grab the quotes ordered ordered by how infrequently they've been returned, and then grab a random one in the set. But for our purposes, it's fine. If there aren't any quotes, it will return None. :return: ``Quote`` object or None \"\"\" quotes_to_pick = ( Quote . objects . filter ( source = self ) . select_related ( \"stats\" ) . order_by ( \"stats__times_used\" )[: max_quotes_to_process ] ) if quotes_to_pick . exists (): # Select a random index in the result set. quote_to_return = random . choice ( list ( quotes_to_pick )) quote_random_retrieved . send ( type ( self ), instance = self , quote_retrieved = quote_to_return ) return quote_to_return return None","title":"get_random_quote()"},{"location":"managing_quotes/#quote","text":"A quote from a given source. Attributes: Name Type Description id int Database primary key for the object. quote str The quote text to use. You can use Markdown for styling. Must be <= 280 characters for tweets quote_rendered str HTML rendered version of the quote field. Automatically generated. citation str Optional description of quote source, e.g. episode number or book title. citation_url str Optional accompanying URL for the citation. character Source The source of this quote. owner User The user that created and owns this quote. created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class Quote ( AbstractOwnerModel , RulesModelMixin , TimeStampedModel , metaclass = RulesModelBase ): \"\"\" A quote from a given source. Attributes: id (int): Database primary key for the object. quote (str): The quote text to use. You can use Markdown for styling. Must be <= 280 characters for tweets quote_rendered (str): HTML rendered version of the quote field. Automatically generated. citation (str): Optional description of quote source, e.g. episode number or book title. citation_url (str): Optional accompanying URL for the citation. character (Source): The source of this quote. owner (User): The user that created and owns this quote. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" quote = models . CharField ( max_length = 280 , # Keep the base limit to 280 so that quotes are 'tweetable' help_text = \"Plain text representation of quote. You can use Markdown here.\" , ) quote_rendered = models . TextField ( null = True , blank = True , help_text = _ ( \"HTML rendered version of quote generated from quote plain text.\" ), ) source = models . ForeignKey ( Source , on_delete = models . CASCADE , help_text = _ ( \"The source of this quote, i.e. name.\" ), ) citation = models . CharField ( max_length = 250 , blank = True , null = True , help_text = _ ( \"Where is this quote from? Episode #, book?\" ), ) citation_url = models . URLField ( null = True , blank = True , help_text = _ ( \"URL for citation, if applicable.\" ) ) def __str__ ( self ): # pragma: nocover return f \" { self . source . name } : { self . quote } \" class Meta : rules_permissions = { # \"add\": is_character_owner, \"read\" : is_owner_or_public , \"edit\" : is_owner , \"delete\" : is_owner , }","title":"Quote"},{"location":"managing_quotes/#source-markov-model","text":"The cached markov model for a given source. The database object for this is automatically created whenever a new character object is saved. Attributes: Name Type Description id int Database primary key for the object. source Source The character who the model is sourced from. data json The JSON representation of the Markov model created by markovify . created datetime When this object was first created. Auto-generated. modified datetime Last time this object was modified. Auto-generated. Source code in django_quotes/models.py class SourceMarkovModel ( TimeStampedModel ): \"\"\" The cached markov model for a given source. The database object for this is automatically created whenever a new character object is saved. Attributes: id (int): Database primary key for the object. source (Source): The character who the model is sourced from. data (json): The JSON representation of the Markov model created by ``markovify``. created (datetime): When this object was first created. Auto-generated. modified (datetime): Last time this object was modified. Auto-generated. \"\"\" source = models . OneToOneField ( Source , on_delete = models . CASCADE ) data = models . JSONField ( null = True , blank = True ) def generate_model_from_corpus ( self ): \"\"\" Collect all quotes attributed to the related character. Then create, compile, and save the model. \"\"\" logger . debug ( \"Generating text model. Fetching quotes.\" ) quotes = Quote . objects . filter ( source = self . source ) # Don't bother generating model if there isn't data. if not quotes . exists (): # pragma: nocover logger . debug ( \"There are no quotes. Returning None.\" ) return logger . debug ( \"Quotes retrieved! Forming into corpus.\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Building text model.\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model.\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving model as JSON.\" ) self . data = text_model . to_json () self . save () logger . debug ( \"Markov model populated to database.\" ) def __str__ ( self ): # pragma: nocover return self . source . name","title":"Source Markov Model"},{"location":"managing_quotes/#django_quotes.models.SourceMarkovModel.generate_model_from_corpus","text":"Collect all quotes attributed to the related character. Then create, compile, and save the model. Source code in django_quotes/models.py def generate_model_from_corpus ( self ): \"\"\" Collect all quotes attributed to the related character. Then create, compile, and save the model. \"\"\" logger . debug ( \"Generating text model. Fetching quotes.\" ) quotes = Quote . objects . filter ( source = self . source ) # Don't bother generating model if there isn't data. if not quotes . exists (): # pragma: nocover logger . debug ( \"There are no quotes. Returning None.\" ) return logger . debug ( \"Quotes retrieved! Forming into corpus.\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Building text model.\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model.\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving model as JSON.\" ) self . data = text_model . to_json () self . save () logger . debug ( \"Markov model populated to database.\" )","title":"generate_model_from_corpus()"},{"location":"managing_quotes/#group-markov-model","text":"The cached markov model for the entire group. It is made up of every quote from every markov enabled character within the group. Attributes: Name Type Description id int The database id of this object. group SourceGroup The OneToOne relationship to SourceGroup data json The cached markov model. created datetime When the object was created. modified datetime When the object was last modified. Source code in django_quotes/models.py class GroupMarkovModel ( TimeStampedModel ): \"\"\" The cached markov model for the entire group. It is made up of every quote from every markov enabled character within the group. Attributes: id (int): The database id of this object. group (SourceGroup): The OneToOne relationship to ``SourceGroup`` data (json): The cached markov model. created (datetime): When the object was created. modified (datetime): When the object was last modified. \"\"\" group = models . OneToOneField ( SourceGroup , on_delete = models . CASCADE , help_text = _ ( \"The character group this model belongs to.\" ), ) data = models . JSONField ( null = True , blank = True , help_text = _ ( \"The cached markov model as JSON.\" ) ) def generate_model_from_corpus ( self ): \"\"\" Collect all quotes from markov enabled characters in this group and then compile the model and save it. \"\"\" logger . debug ( f \"Gathering corpus for character group: { self . group . name } \" ) quotes = Quote . objects . filter ( source__in = Source . objects . filter ( group = self . group , allow_markov = True ) ) if quotes . exists (): if quotes . count () >= 10 : logger . debug ( \"Found sufficient quotes for a model!\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Forming text model...\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model...\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving compiled model to JSON...\" ) self . data = text_model . to_json () self . save () logger . debug ( f \"Finished building and saving group markov model for { self . group . name } !\" )","title":"Group Markov Model"},{"location":"managing_quotes/#django_quotes.models.GroupMarkovModel.generate_model_from_corpus","text":"Collect all quotes from markov enabled characters in this group and then compile the model and save it. Source code in django_quotes/models.py def generate_model_from_corpus ( self ): \"\"\" Collect all quotes from markov enabled characters in this group and then compile the model and save it. \"\"\" logger . debug ( f \"Gathering corpus for character group: { self . group . name } \" ) quotes = Quote . objects . filter ( source__in = Source . objects . filter ( group = self . group , allow_markov = True ) ) if quotes . exists (): if quotes . count () >= 10 : logger . debug ( \"Found sufficient quotes for a model!\" ) corpus = \" \" . join ( quote . quote for quote in quotes ) logger . debug ( \"Forming text model...\" ) text_model = MarkovPOSText ( corpus ) logger . debug ( \"Compiling text model...\" ) text_model . compile ( inplace = True ) logger . debug ( \"Saving compiled model to JSON...\" ) self . data = text_model . to_json () self . save () logger . debug ( f \"Finished building and saving group markov model for { self . group . name } !\" )","title":"generate_model_from_corpus()"},{"location":"managing_quotes/#group-stats","text":"An object for using to track usage stats for CharacterGroup . Attributes: Name Type Description group SourceGroup The group this is collecting stats for. quotes_requested int The number of times a quote from this object or its children has been requested. quotes_generated int The number of times a markov quote has been generated for this or it's children. Source code in django_quotes/models.py class GroupStats ( TimeStampedModel ): \"\"\" An object for using to track usage stats for ``CharacterGroup``. Attributes: group (SourceGroup): The group this is collecting stats for. quotes_requested (int): The number of times a quote from this object or its children has been requested. quotes_generated (int): The number of times a markov quote has been generated for this or it's children. \"\"\" group = models . OneToOneField ( SourceGroup , related_name = \"stats\" , on_delete = models . CASCADE ) quotes_requested = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of time child quotes have been requested.\" ) ) quotes_generated = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of times markov generated quotes have been requested.\" ), )","title":"Group Stats"},{"location":"managing_quotes/#source-stats","text":"An object for using to track usage stats for Character . Attributes: Name Type Description source Source The source this is collecting stats for. quotes_requested int The number of times a quote from this object or its children has been requested. quotes_generated int The number of times a markov quote has been generated for this or it's children. Source code in django_quotes/models.py class SourceStats ( TimeStampedModel ): \"\"\" An object for using to track usage stats for ``Character``. Attributes: source (Source): The source this is collecting stats for. quotes_requested (int): The number of times a quote from this object or its children has been requested. quotes_generated (int): The number of times a markov quote has been generated for this or it's children. \"\"\" source = models . OneToOneField ( Source , related_name = \"stats\" , on_delete = models . CASCADE ) quotes_requested = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of time child quotes have been requested.\" ) ) quotes_generated = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Number of times markov generated quotes have been requested.\" ), )","title":"Source Stats"},{"location":"managing_quotes/#quote-stats","text":"A simple object used to track how often an individual quote is used. Attributes: Name Type Description id int The database primary key of this object. quote Quote The quote this stat relates to. times_used int The number of times this has been used by an service such as random quote. created datetime When this was created. modified datetime When this was last modified. Source code in django_quotes/models.py class QuoteStats ( TimeStampedModel ): \"\"\" A simple object used to track how often an individual quote is used. Attributes: id (int): The database primary key of this object. quote (Quote): The quote this stat relates to. times_used (int): The number of times this has been used by an service such as random quote. created (datetime): When this was created. modified (datetime): When this was last modified. \"\"\" quote = models . OneToOneField ( Quote , on_delete = models . CASCADE , related_name = \"stats\" , help_text = _ ( \"The Quote the stats related to.\" ), ) times_used = models . PositiveIntegerField ( default = 0 , help_text = _ ( \"Times used for random quotes, etc.\" ) ) def __str__ ( self ): # pragma: nocover return f \"Stats for Quote { self . quote . id } \"","title":"Quote Stats"},{"location":"managing_quotes/#views","text":"The core views for managing the quotes consist of simple data entry and manipulation functions, heavily utilizing Django's generic views. All views require login.","title":"Views"},{"location":"managing_quotes/#source-group-list","text":"Provides a paginated list of source groups created by logged in user. Served at /app/groups/ .","title":"Source Group List"},{"location":"managing_quotes/#source-group-create","text":"Allows a user to define a new SourceGroup . Served at app/groups/create/ .","title":"Source Group Create"},{"location":"managing_quotes/#source-group-detail","text":"Displays a detailed view of a source group with a sampling of the :ref: Source objects associated, with links to full listings. Served at app/groups/<slug:group>/ .","title":"Source Group Detail"},{"location":"managing_quotes/#source-group-update","text":"Allows user to update the source group's attributes. Served at app/groups/<slug:group>/edit/ .","title":"Source Group Update"},{"location":"managing_quotes/#source-group-delete","text":"Allows user to delete a SourceGroup and all child data associated with it. Served at app/groups/<slug:group>/delete/ .","title":"Source Group Delete"},{"location":"managing_quotes/#source-list","text":"Paginated list of all the :ref: Source objects associated with a given group, along with aggregate statistics such as total quotes. Served at app/groups/<slug:group>/sources/ .","title":"Source List"},{"location":"managing_quotes/#source-create","text":"Enables a user to create a new Source for a given SourceGroup . Served at app/groups/<slug:group>/sources/create/ .","title":"Source Create"},{"location":"managing_quotes/#source-detail","text":"Detail view of the :ref: Source object including a sampling of recently created/modified quotes with links to full listings. Served at app/sources/<slug:source>/ .","title":"Source Detail"},{"location":"managing_quotes/#source-update","text":"Enables editing of the source attributes such as name, description, whether to allow markov requests, etc. Served at app/sources/<slug:source>/edit/ .","title":"Source Update"},{"location":"managing_quotes/#source-delete","text":"Enable deleting a source and all child data associated with it. Served at app/sources/<slug:source>/delete/ .","title":"Source Delete"},{"location":"managing_quotes/#quote-list","text":"Provides a paginated list of quotes created for the given :ref: Source . Served at app/sources/<slug:source>/quotes/ .","title":"Quote List"},{"location":"managing_quotes/#quote-create","text":"Add a quote for the given Source . Served at app/sources/<slug:source>/quotes/create/ .","title":"Quote Create"},{"location":"managing_quotes/#quote-detail","text":"Shows details of the quote including the HTML rendered version of the text, and in the future will also include statistical data. Served at app/quotes/<int:quote>/ .","title":"Quote Detail"},{"location":"managing_quotes/#quote-update","text":"Enables the user to update the quote text for a given Quote object. Served at app/quotes/<int:quote>/edit/ .","title":"Quote Update"},{"location":"managing_quotes/#quote-delete","text":"Enables the user to delete a given Quote object. Served at app/quotes/<int:quote>/delete/ .","title":"Quote Delete"},{"location":"managing_quotes/#signals","text":"There are two signals provided that are used to update statistics related to SourceGroup , Source , and Quote objects. If you implement your own methods and want to ensure your stats related to quotes_requested and quotes_generated remain accurate, you will need to send these.","title":"Signals"},{"location":"managing_quotes/#quote-retrieved","text":"django_quotes . signals . quote_random_retrieved . send ( sender , instance , quote_retrieved , * args , ** kwargs ) The sender should in most contexts be either Source or SourceGroup class definitions ( not instances ). The instance should be the actual instance of the Source that is being used. This signal will update the quotes_retrieved stats in the related GroupStats , SourceStats , and QuoteStats objects.","title":"Quote Retrieved"},{"location":"managing_quotes/#quote-generated","text":"django_quotes . signals . markov_sentence_generated . send ( sender , instance , * args , ** kwargs ) The sender should in most contexts be either Source or SourceGroup class definitions ( not instances ). The instance should be the actual instance of the Source that is being used. This signal will update the quotes_generated stats in the related GroupStats and SourceStats objects.","title":"Quote Generated"},{"location":"managing_quotes/#management-commands","text":"django-quotes provides a management command you can use to check and generate new Markov models for both SourceGroup and Source objects. bash python manage.py makemarkov","title":"Management Commands"},{"location":"quickstart/","text":"Quickstart Django-Quotes uses markovify in conjunction with natural language processing functions form spacy so installation and configuration requires some additional steps. Installation First install django-quotes using a tool like pip. \ud83c\udf89 Look, it's the way you install almost every library! pip install django-quotes Because we're using spacy , we also need to download the language model we are using, which is en_core_web_sm . 1 While there are a number of ugly ways to annotate this process, it's safer for you to do the installation directly using the following command. It's an extra step because academia. python -m spacy download en_core_web_sm Configuration Application Settings Now we need to configure our Django project to use django-quotes . Because we provide object-based permissions and a REST API, you'll also need to enable Django REST Framework and django-rules . Unless you plan on overriding the included templates, you should also include crispy-forms . settings.py # Number of quotes to fetch when doing random selections from a single source. # Optional. Default is 50. MAX_QUOTES_FOR_RANDOM_SET = 50 # Number of quotes to fetch when doing random selections from a SourceGroup. # Optional. Default is 50. MAX_QUOTES_FOR_RANDOM_GROUP_SET = 50 INSTALLED_APPS = [ \"django.contrib.auth\" , \"django.contrib.contenttypes\" , \"django.contrib.sessions\" , \"django.contrib.sites\" , \"django.contrib.messages\" , \"django.contrib.staticfiles\" , # \"django.contrib.humanize\", # Handy template tags \"django.contrib.admin\" , \"django.forms\" , \"crispy_forms\" , \"rest_framework\" , \"rest_framework.authtoken\" , \"corsheaders\" , \"drf_spectacular\" , \"rules.apps.AutodiscoverRulesConfig\" , \"django_quotes\" , # Your stuff: custom apps go here ] # AUTHENTICATION # ------------------------------------------------------------------------------ # https://docs.djangoproject.com/en/dev/ref/settings/#authentication-backends AUTHENTICATION_BACKENDS = [ \"rules.permissions.ObjectPermissionBackend\" , \"django.contrib.auth.backends.ModelBackend\" , ] # MIDDLEWARE # ------------------------------------------------------------------------------ # https://docs.djangoproject.com/en/dev/ref/settings/#middleware MIDDLEWARE = [ \"django.middleware.security.SecurityMiddleware\" , \"corsheaders.middleware.CorsMiddleware\" , \"django.contrib.sessions.middleware.SessionMiddleware\" , \"django.middleware.locale.LocaleMiddleware\" , \"django.middleware.common.CommonMiddleware\" , \"django.middleware.csrf.CsrfViewMiddleware\" , \"django.contrib.auth.middleware.AuthenticationMiddleware\" , \"django.contrib.messages.middleware.MessageMiddleware\" , \"django.middleware.common.BrokenLinkEmailsMiddleware\" , \"django.middleware.clickjacking.XFrameOptionsMiddleware\" , ] # django-rest-framework # ------------------------------------------------------------------------------- # django-rest-framework - https://www.django-rest-framework.org/api-guide/settings/ REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\" : ( \"rest_framework.authentication.SessionAuthentication\" , \"rest_framework.authentication.TokenAuthentication\" , ), \"DEFAULT_PERMISSION_CLASSES\" : ( \"rest_framework.permissions.IsAuthenticated\" ,), \"DEFAULT_SCHEMA_CLASS\" : \"drf_spectacular.openapi.AutoSchema\" , } # django-cors-headers - https://github.com/adamchainz/django-cors-headers#setup CORS_URLS_REGEX = r \"^/api/.*$\" # By Default swagger ui is available only to admin user. You can change permission classs to change that # See more configuration options at https://drf-spectacular.readthedocs.io/en/latest/settings.html#settings SPECTACULAR_SETTINGS = { \"TITLE\" : \"Django Quotes API\" , \"DESCRIPTION\" : \"Documentation of API endpoints of Django Quotes\" , \"VERSION\" : \"1.0.0\" , \"SERVE_PERMISSIONS\" : [ \"rest_framework.permissions.IsAdminUser\" ], \"SERVERS\" : [ { \"url\" : \"https://127.0.0.1:8000\" , \"description\" : \"Local Development server\" }, ], } URL Settings First, configure your API router. api_router.py from django.conf import settings from rest_framework.routers import DefaultRouter , SimpleRouter from django_quotes.api.views import SourceGroupViewSet , SourceViewSet if settings . DEBUG : router = DefaultRouter () else : router = SimpleRouter () router . register ( \"groups\" , SourceGroupViewSet , basename = \"group\" ) router . register ( \"sources\" , SourceViewSet , basename = \"source\" ) app_name = \"api\" urlpatterns = router . urls Then you will need to wire up the views to your project URLs configuration as displayed below. urls.py urlpatterns = [ # Chose whatever path your want, but keep the namespace as ``quotes``. path ( \"app/\" , include ( \"django_quotes.urls\" , namespace = \"quotes\" )), # API base url. You can change this path if you like. path ( \"api/\" , include ( \"path.to.your.api_router\" )), # DRF auth token path ( \"auth-token/\" , obtain_auth_token ), path ( \"api/schema/\" , SpectacularAPIView . as_view (), name = \"api-schema\" ), path ( \"api/docs/\" , SpectacularSwaggerView . as_view ( url_name = \"api-schema\" ), name = \"api-docs\" , ), # Insert your other URLS here. ] Customizing Templates (Optional) If you want to override the existing templates, you can. By default they are Bootstrap 5 -compatible, although we do not bundle Bootstrap within the project. To override, create a templates/quotes directory in your project and add the following templates: ls django_quotes/templates/quotes group_create.html group_delete.html group_detail.html group_list.html group_update.html quote_create.html quote_delete.html quote_detail.html quote_list.html quote_update.html source_create.html source_delete.html source_detail.html source_list.html source_update.html Usage By default, django-quotes provides access via the admin site, and provides a set of basic views for managing the quotes and associated data. See Managing Quotes for more information. Other languages are not supported at this time. \u21a9","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Django-Quotes uses markovify in conjunction with natural language processing functions form spacy so installation and configuration requires some additional steps.","title":"Quickstart"},{"location":"quickstart/#installation","text":"First install django-quotes using a tool like pip. \ud83c\udf89 Look, it's the way you install almost every library! pip install django-quotes Because we're using spacy , we also need to download the language model we are using, which is en_core_web_sm . 1 While there are a number of ugly ways to annotate this process, it's safer for you to do the installation directly using the following command. It's an extra step because academia. python -m spacy download en_core_web_sm","title":"Installation"},{"location":"quickstart/#configuration","text":"","title":"Configuration"},{"location":"quickstart/#application-settings","text":"Now we need to configure our Django project to use django-quotes . Because we provide object-based permissions and a REST API, you'll also need to enable Django REST Framework and django-rules . Unless you plan on overriding the included templates, you should also include crispy-forms . settings.py # Number of quotes to fetch when doing random selections from a single source. # Optional. Default is 50. MAX_QUOTES_FOR_RANDOM_SET = 50 # Number of quotes to fetch when doing random selections from a SourceGroup. # Optional. Default is 50. MAX_QUOTES_FOR_RANDOM_GROUP_SET = 50 INSTALLED_APPS = [ \"django.contrib.auth\" , \"django.contrib.contenttypes\" , \"django.contrib.sessions\" , \"django.contrib.sites\" , \"django.contrib.messages\" , \"django.contrib.staticfiles\" , # \"django.contrib.humanize\", # Handy template tags \"django.contrib.admin\" , \"django.forms\" , \"crispy_forms\" , \"rest_framework\" , \"rest_framework.authtoken\" , \"corsheaders\" , \"drf_spectacular\" , \"rules.apps.AutodiscoverRulesConfig\" , \"django_quotes\" , # Your stuff: custom apps go here ] # AUTHENTICATION # ------------------------------------------------------------------------------ # https://docs.djangoproject.com/en/dev/ref/settings/#authentication-backends AUTHENTICATION_BACKENDS = [ \"rules.permissions.ObjectPermissionBackend\" , \"django.contrib.auth.backends.ModelBackend\" , ] # MIDDLEWARE # ------------------------------------------------------------------------------ # https://docs.djangoproject.com/en/dev/ref/settings/#middleware MIDDLEWARE = [ \"django.middleware.security.SecurityMiddleware\" , \"corsheaders.middleware.CorsMiddleware\" , \"django.contrib.sessions.middleware.SessionMiddleware\" , \"django.middleware.locale.LocaleMiddleware\" , \"django.middleware.common.CommonMiddleware\" , \"django.middleware.csrf.CsrfViewMiddleware\" , \"django.contrib.auth.middleware.AuthenticationMiddleware\" , \"django.contrib.messages.middleware.MessageMiddleware\" , \"django.middleware.common.BrokenLinkEmailsMiddleware\" , \"django.middleware.clickjacking.XFrameOptionsMiddleware\" , ] # django-rest-framework # ------------------------------------------------------------------------------- # django-rest-framework - https://www.django-rest-framework.org/api-guide/settings/ REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\" : ( \"rest_framework.authentication.SessionAuthentication\" , \"rest_framework.authentication.TokenAuthentication\" , ), \"DEFAULT_PERMISSION_CLASSES\" : ( \"rest_framework.permissions.IsAuthenticated\" ,), \"DEFAULT_SCHEMA_CLASS\" : \"drf_spectacular.openapi.AutoSchema\" , } # django-cors-headers - https://github.com/adamchainz/django-cors-headers#setup CORS_URLS_REGEX = r \"^/api/.*$\" # By Default swagger ui is available only to admin user. You can change permission classs to change that # See more configuration options at https://drf-spectacular.readthedocs.io/en/latest/settings.html#settings SPECTACULAR_SETTINGS = { \"TITLE\" : \"Django Quotes API\" , \"DESCRIPTION\" : \"Documentation of API endpoints of Django Quotes\" , \"VERSION\" : \"1.0.0\" , \"SERVE_PERMISSIONS\" : [ \"rest_framework.permissions.IsAdminUser\" ], \"SERVERS\" : [ { \"url\" : \"https://127.0.0.1:8000\" , \"description\" : \"Local Development server\" }, ], }","title":"Application Settings"},{"location":"quickstart/#url-settings","text":"First, configure your API router. api_router.py from django.conf import settings from rest_framework.routers import DefaultRouter , SimpleRouter from django_quotes.api.views import SourceGroupViewSet , SourceViewSet if settings . DEBUG : router = DefaultRouter () else : router = SimpleRouter () router . register ( \"groups\" , SourceGroupViewSet , basename = \"group\" ) router . register ( \"sources\" , SourceViewSet , basename = \"source\" ) app_name = \"api\" urlpatterns = router . urls Then you will need to wire up the views to your project URLs configuration as displayed below. urls.py urlpatterns = [ # Chose whatever path your want, but keep the namespace as ``quotes``. path ( \"app/\" , include ( \"django_quotes.urls\" , namespace = \"quotes\" )), # API base url. You can change this path if you like. path ( \"api/\" , include ( \"path.to.your.api_router\" )), # DRF auth token path ( \"auth-token/\" , obtain_auth_token ), path ( \"api/schema/\" , SpectacularAPIView . as_view (), name = \"api-schema\" ), path ( \"api/docs/\" , SpectacularSwaggerView . as_view ( url_name = \"api-schema\" ), name = \"api-docs\" , ), # Insert your other URLS here. ]","title":"URL Settings"},{"location":"quickstart/#customizing-templates-optional","text":"If you want to override the existing templates, you can. By default they are Bootstrap 5 -compatible, although we do not bundle Bootstrap within the project. To override, create a templates/quotes directory in your project and add the following templates: ls django_quotes/templates/quotes group_create.html group_delete.html group_detail.html group_list.html group_update.html quote_create.html quote_delete.html quote_detail.html quote_list.html quote_update.html source_create.html source_delete.html source_detail.html source_list.html source_update.html","title":"Customizing Templates (Optional)"},{"location":"quickstart/#usage","text":"By default, django-quotes provides access via the admin site, and provides a set of basic views for managing the quotes and associated data. See Managing Quotes for more information. Other languages are not supported at this time. \u21a9","title":"Usage"},{"location":"security/","text":"Security \ud83d\udd10 Reporting Security Issues Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge. Vulnerabilities can be reported by emailing core members: Daniel Andrlik daniel@andrlik.org Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Environment (e.g. Linux / Windows / macOS) Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. Preferred Languages We prefer all communications to be in English.","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#reporting-security-issues","text":"Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge. Vulnerabilities can be reported by emailing core members: Daniel Andrlik daniel@andrlik.org Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Environment (e.g. Linux / Windows / macOS) Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly.","title":"\ud83d\udd10 Reporting Security Issues"},{"location":"security/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"}]}